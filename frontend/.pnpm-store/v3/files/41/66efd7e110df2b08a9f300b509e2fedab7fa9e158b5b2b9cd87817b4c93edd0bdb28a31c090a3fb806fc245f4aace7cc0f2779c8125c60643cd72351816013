import * as u from "react";
import { H as U, I as D, W as Oe, P as e, G as fe, L as z, Z as fo } from "./identifier-B7MO0PvI.js";
import { f as Ce } from "./formControlState-vgaj2ksH.js";
import { u as Ie } from "./useFormControl-CatNKXAi.js";
import { s as h, r as k, u as H, c as V, f as bo, e as mo } from "./DefaultPropsProvider-BYFwNPLt.js";
import { m as E } from "./memoTheme-CqfvfBST.js";
import { jsx as v, jsxs as Se } from "react/jsx-runtime";
import { a as go, b as vo } from "./FormLabel-B11aqT37.js";
import { M as yo } from "./Menu-ysG9uY3e.js";
import { r as G } from "./refType-BqQbA6de.js";
import { i as ho } from "./utils-DWqc1kRF.js";
import { u as Ve } from "./useControlled-BYdyS7Pn.js";
import { u as Xe } from "./useForkRef-C_4o__cU.js";
import { o as Oo } from "./ownerDocument-CUrv0DIK.js";
import { u as Co } from "./useId-CK6Kn3Tn.js";
import { c as Io } from "./createSvgIcon-BS0Qe85N.js";
import { c as Re } from "./createSimplePaletteValueFilter-B7--0ryQ.js";
import { i as xe, a as we, r as Te, b as Ne, c as Pe, I as $e } from "./InputBase-CHytwRH8.js";
import { g as So } from "./utils-jA5a7WHN.js";
function Ro(o) {
  return U("MuiInput", o);
}
const K = {
  ...xe,
  ...D("MuiInput", ["root", "underline", "input"])
}, xo = (o) => {
  const {
    classes: t,
    disableUnderline: n
  } = o, i = V({
    root: ["root", !n && "underline"],
    input: ["input"]
  }, Ro, t);
  return {
    ...t,
    // forward classes to the InputBase
    ...i
  };
}, wo = h(we, {
  shouldForwardProp: (o) => k(o) || o === "classes",
  name: "MuiInput",
  slot: "Root",
  overridesResolver: (o, t) => {
    const {
      ownerState: n
    } = o;
    return [...Te(o, t), !n.disableUnderline && t.underline];
  }
})(E(({
  theme: o
}) => {
  let n = o.palette.mode === "light" ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  return o.vars && (n = `rgba(${o.vars.palette.common.onBackgroundChannel} / ${o.vars.opacity.inputUnderline})`), {
    position: "relative",
    variants: [{
      props: ({
        ownerState: r
      }) => r.formControl,
      style: {
        "label + &": {
          marginTop: 16
        }
      }
    }, {
      props: ({
        ownerState: r
      }) => !r.disableUnderline,
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: o.transitions.create("transform", {
            duration: o.transitions.duration.shorter,
            easing: o.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${K.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${K.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (o.vars || o).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${n}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: o.transitions.create("border-bottom-color", {
            duration: o.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${K.disabled}, .${K.error}):before`]: {
          borderBottom: `2px solid ${(o.vars || o).palette.text.primary}`,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            borderBottom: `1px solid ${n}`
          }
        },
        [`&.${K.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, ...Object.entries(o.palette).filter(Re()).map(([r]) => ({
      props: {
        color: r,
        disableUnderline: !1
      },
      style: {
        "&::after": {
          borderBottom: `2px solid ${(o.vars || o).palette[r].main}`
        }
      }
    }))]
  };
})), To = h(Ne, {
  name: "MuiInput",
  slot: "Input",
  overridesResolver: Pe
})({}), de = /* @__PURE__ */ u.forwardRef(function(t, n) {
  const r = H({
    props: t,
    name: "MuiInput"
  }), {
    disableUnderline: i = !1,
    components: p = {},
    componentsProps: a,
    fullWidth: d = !1,
    inputComponent: m = "input",
    multiline: g = !1,
    slotProps: f,
    slots: c = {},
    type: O = "text",
    ...R
  } = r, w = xo(r), y = {
    root: {
      ownerState: {
        disableUnderline: i
      }
    }
  }, x = f ?? a ? Oe(f ?? a, y) : y, C = c.root ?? p.Root ?? wo, I = c.input ?? p.Input ?? To;
  return /* @__PURE__ */ v($e, {
    slots: {
      root: C,
      input: I
    },
    slotProps: x,
    fullWidth: d,
    inputComponent: m,
    multiline: g,
    ref: n,
    type: O,
    ...R,
    classes: w
  });
});
process.env.NODE_ENV !== "production" && (de.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: e.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: e.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: e.object,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: e.oneOfType([e.oneOf(["primary", "secondary"]), e.string]),
  /**
   * The components used for each slot inside.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  components: e.shape({
    Input: e.elementType,
    Root: e.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @deprecated use the `slotProps` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  componentsProps: e.shape({
    input: e.object,
    root: e.object
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: e.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: e.bool,
  /**
   * If `true`, the `input` will not have an underline.
   * @default false
   */
  disableUnderline: e.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: e.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: e.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: e.bool,
  /**
   * The id of the `input` element.
   */
  id: e.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: e.elementType,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: e.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: G,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: e.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: e.oneOfType([e.number, e.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: e.oneOfType([e.number, e.string]),
  /**
   * If `true`, a [TextareaAutosize](https://mui.com/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: e.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: e.string,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: e.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: e.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: e.bool,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: e.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: e.oneOfType([e.number, e.string]),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: e.shape({
    input: e.object,
    root: e.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: e.shape({
    input: e.elementType,
    root: e.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: e.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: e.oneOfType([e.arrayOf(e.oneOfType([e.func, e.object, e.bool])), e.func, e.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   * @default 'text'
   */
  type: e.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: e.any
});
de && (de.muiName = "Input");
function No(o) {
  return U("MuiInputLabel", o);
}
const It = D("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]), Po = (o) => {
  const {
    classes: t,
    formControl: n,
    size: r,
    shrink: i,
    disableAnimation: p,
    variant: a,
    required: d
  } = o, m = {
    root: ["root", n && "formControl", !p && "animated", i && "shrink", r && r !== "normal" && `size${z(r)}`, a],
    asterisk: [d && "asterisk"]
  }, g = V(m, No, t);
  return {
    ...t,
    // forward the focused, disabled, etc. classes to the FormLabel
    ...g
  };
}, $o = h(go, {
  shouldForwardProp: (o) => k(o) || o === "classes",
  name: "MuiInputLabel",
  slot: "Root",
  overridesResolver: (o, t) => {
    const {
      ownerState: n
    } = o;
    return [{
      [`& .${vo.asterisk}`]: t.asterisk
    }, t.root, n.formControl && t.formControl, n.size === "small" && t.sizeSmall, n.shrink && t.shrink, !n.disableAnimation && t.animated, n.focused && t.focused, t[n.variant]];
  }
})(E(({
  theme: o
}) => ({
  display: "block",
  transformOrigin: "top left",
  whiteSpace: "nowrap",
  overflow: "hidden",
  textOverflow: "ellipsis",
  maxWidth: "100%",
  variants: [{
    props: ({
      ownerState: t
    }) => t.formControl,
    style: {
      position: "absolute",
      left: 0,
      top: 0,
      // slight alteration to spec spacing to match visual spec result
      transform: "translate(0, 20px) scale(1)"
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      // Compensation for the `Input.inputSizeSmall` style.
      transform: "translate(0, 17px) scale(1)"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.shrink,
    style: {
      transform: "translate(0, -1.5px) scale(0.75)",
      transformOrigin: "top left",
      maxWidth: "133%"
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.disableAnimation,
    style: {
      transition: o.transitions.create(["color", "transform", "max-width"], {
        duration: o.transitions.duration.shorter,
        easing: o.transitions.easing.easeOut
      })
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      // Chrome's autofill feature gives the input field a yellow background.
      // Since the input field is behind the label in the HTML tree,
      // the input field is drawn last and hides the label with an opaque background color.
      // zIndex: 1 will raise the label above opaque background-colors of input.
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(12px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }
  }, {
    props: {
      variant: "filled",
      size: "small"
    },
    style: {
      transform: "translate(12px, 13px) scale(1)"
    }
  }, {
    props: ({
      variant: t,
      ownerState: n
    }) => t === "filled" && n.shrink,
    style: {
      userSelect: "none",
      pointerEvents: "auto",
      transform: "translate(12px, 7px) scale(0.75)",
      maxWidth: "calc(133% - 24px)"
    }
  }, {
    props: ({
      variant: t,
      ownerState: n,
      size: r
    }) => t === "filled" && n.shrink && r === "small",
    style: {
      transform: "translate(12px, 4px) scale(0.75)"
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      // see comment above on filled.zIndex
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(14px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }
  }, {
    props: {
      variant: "outlined",
      size: "small"
    },
    style: {
      transform: "translate(14px, 9px) scale(1)"
    }
  }, {
    props: ({
      variant: t,
      ownerState: n
    }) => t === "outlined" && n.shrink,
    style: {
      userSelect: "none",
      pointerEvents: "auto",
      // Theoretically, we should have (8+5)*2/0.75 = 34px
      // but it feels a better when it bleeds a bit on the left, so 32px.
      maxWidth: "calc(133% - 32px)",
      transform: "translate(14px, -9px) scale(0.75)"
    }
  }]
}))), ko = /* @__PURE__ */ u.forwardRef(function(t, n) {
  const r = H({
    name: "MuiInputLabel",
    props: t
  }), {
    disableAnimation: i = !1,
    margin: p,
    shrink: a,
    variant: d,
    className: m,
    ...g
  } = r, f = Ie();
  let c = a;
  typeof c > "u" && f && (c = f.filled || f.focused || f.adornedStart);
  const O = Ce({
    props: r,
    muiFormControl: f,
    states: ["size", "variant", "required", "focused"]
  }), R = {
    ...r,
    disableAnimation: i,
    formControl: f,
    shrink: c,
    size: O.size,
    variant: O.variant,
    required: O.required,
    focused: O.focused
  }, w = Po(R);
  return /* @__PURE__ */ v($o, {
    "data-shrink": c,
    ref: n,
    className: fe(w.root, m),
    ...g,
    ownerState: R,
    classes: w
  });
});
process.env.NODE_ENV !== "production" && (ko.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * The content of the component.
   */
  children: e.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: e.object,
  /**
   * @ignore
   */
  className: e.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   */
  color: e.oneOfType([e.oneOf(["error", "info", "primary", "secondary", "success", "warning"]), e.string]),
  /**
   * If `true`, the transition animation is disabled.
   * @default false
   */
  disableAnimation: e.bool,
  /**
   * If `true`, the component is disabled.
   */
  disabled: e.bool,
  /**
   * If `true`, the label is displayed in an error state.
   */
  error: e.bool,
  /**
   * If `true`, the `input` of this label is focused.
   */
  focused: e.bool,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   */
  margin: e.oneOf(["dense"]),
  /**
   * if `true`, the label will indicate that the `input` is required.
   */
  required: e.bool,
  /**
   * If `true`, the label is shrunk.
   */
  shrink: e.bool,
  /**
   * The size of the component.
   * @default 'normal'
   */
  size: e.oneOfType([e.oneOf(["normal", "small"]), e.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: e.oneOfType([e.arrayOf(e.oneOfType([e.func, e.object, e.bool])), e.func, e.object]),
  /**
   * The variant to use.
   */
  variant: e.oneOf(["filled", "outlined", "standard"])
});
function Eo(o) {
  return U("MuiNativeSelect", o);
}
const ke = D("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]), Fo = (o) => {
  const {
    classes: t,
    variant: n,
    disabled: r,
    multiple: i,
    open: p,
    error: a
  } = o, d = {
    select: ["select", n, r && "disabled", i && "multiple", a && "error"],
    icon: ["icon", `icon${z(n)}`, p && "iconOpen", r && "disabled"]
  };
  return V(d, Eo, t);
}, He = h("select")(({
  theme: o
}) => ({
  // Reset
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // When interacting quickly, the text can end up selected.
  // Native select can't be selected either.
  userSelect: "none",
  // Reset
  borderRadius: 0,
  cursor: "pointer",
  "&:focus": {
    // Reset Chrome style
    borderRadius: 0
  },
  [`&.${ke.disabled}`]: {
    cursor: "default"
  },
  "&[multiple]": {
    height: "auto"
  },
  "&:not([multiple]) option, &:not([multiple]) optgroup": {
    backgroundColor: (o.vars || o).palette.background.paper
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.variant !== "filled" && t.variant !== "outlined",
    style: {
      // Bump specificity to allow extending custom inputs
      "&&&": {
        paddingRight: 24,
        minWidth: 16
        // So it doesn't collapse.
      }
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      "&&&": {
        paddingRight: 32
      }
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      borderRadius: (o.vars || o).shape.borderRadius,
      "&:focus": {
        borderRadius: (o.vars || o).shape.borderRadius
        // Reset the reset for Chrome style
      },
      "&&&": {
        paddingRight: 32
      }
    }
  }]
})), Mo = h(He, {
  name: "MuiNativeSelect",
  slot: "Select",
  shouldForwardProp: k,
  overridesResolver: (o, t) => {
    const {
      ownerState: n
    } = o;
    return [t.select, t[n.variant], n.error && t.error, {
      [`&.${ke.multiple}`]: t.multiple
    }];
  }
})({}), Ge = h("svg")(({
  theme: o
}) => ({
  // We use a position absolute over a flexbox in order to forward the pointer events
  // to the input and to support wrapping tags..
  position: "absolute",
  right: 0,
  // Center vertically, height is 1em
  top: "calc(50% - .5em)",
  // Don't block pointer events on the select under the icon.
  pointerEvents: "none",
  color: (o.vars || o).palette.action.active,
  [`&.${ke.disabled}`]: {
    color: (o.vars || o).palette.action.disabled
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.open,
    style: {
      transform: "rotate(180deg)"
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      right: 7
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      right: 7
    }
  }]
})), jo = h(Ge, {
  name: "MuiNativeSelect",
  slot: "Icon",
  overridesResolver: (o, t) => {
    const {
      ownerState: n
    } = o;
    return [t.icon, n.variant && t[`icon${z(n.variant)}`], n.open && t.iconOpen];
  }
})({}), Ye = /* @__PURE__ */ u.forwardRef(function(t, n) {
  const {
    className: r,
    disabled: i,
    error: p,
    IconComponent: a,
    inputRef: d,
    variant: m = "standard",
    ...g
  } = t, f = {
    ...t,
    disabled: i,
    variant: m,
    error: p
  }, c = Fo(f);
  return /* @__PURE__ */ Se(u.Fragment, {
    children: [/* @__PURE__ */ v(Mo, {
      ownerState: f,
      className: fe(c.select, r),
      disabled: i,
      ref: d || n,
      ...g
    }), t.multiple ? null : /* @__PURE__ */ v(jo, {
      as: a,
      ownerState: f,
      className: c.icon
    })]
  });
});
process.env.NODE_ENV !== "production" && (Ye.propTypes = {
  /**
   * The option elements to populate the select with.
   * Can be some `<option>` elements.
   */
  children: e.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: e.object,
  /**
   * The CSS class name of the select element.
   */
  className: e.string,
  /**
   * If `true`, the select is disabled.
   */
  disabled: e.bool,
  /**
   * If `true`, the `select input` will indicate an error.
   */
  error: e.bool,
  /**
   * The icon that displays the arrow.
   */
  IconComponent: e.elementType.isRequired,
  /**
   * Use that prop to pass a ref to the native select element.
   * @deprecated
   */
  inputRef: G,
  /**
   * @ignore
   */
  multiple: e.bool,
  /**
   * Name attribute of the `select` or hidden `input` element.
   */
  name: e.string,
  /**
   * Callback fired when a menu item is selected.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: e.func,
  /**
   * The input value.
   */
  value: e.any,
  /**
   * The variant to use.
   */
  variant: e.oneOf(["standard", "outlined", "filled"])
});
function Lo(o) {
  return U("MuiSelect", o);
}
const X = D("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
var qe;
const Bo = h(He, {
  name: "MuiSelect",
  slot: "Select",
  overridesResolver: (o, t) => {
    const {
      ownerState: n
    } = o;
    return [
      // Win specificity over the input base
      {
        [`&.${X.select}`]: t.select
      },
      {
        [`&.${X.select}`]: t[n.variant]
      },
      {
        [`&.${X.error}`]: t.error
      },
      {
        [`&.${X.multiple}`]: t.multiple
      }
    ];
  }
})({
  // Win specificity over the input base
  [`&.${X.select}`]: {
    height: "auto",
    // Resets for multiple select with chips
    minHeight: "1.4375em",
    // Required for select\text-field height consistency
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden"
  }
}), Wo = h(Ge, {
  name: "MuiSelect",
  slot: "Icon",
  overridesResolver: (o, t) => {
    const {
      ownerState: n
    } = o;
    return [t.icon, n.variant && t[`icon${z(n.variant)}`], n.open && t.iconOpen];
  }
})({}), Ao = h("input", {
  shouldForwardProp: (o) => bo(o) && o !== "classes",
  name: "MuiSelect",
  slot: "NativeInput",
  overridesResolver: (o, t) => t.nativeInput
})({
  bottom: 0,
  left: 0,
  position: "absolute",
  opacity: 0,
  pointerEvents: "none",
  width: "100%",
  boxSizing: "border-box"
});
function _e(o, t) {
  return typeof t == "object" && t !== null ? o === t : String(o) === String(t);
}
function Uo(o) {
  return o == null || typeof o == "string" && !o.trim();
}
const Do = (o) => {
  const {
    classes: t,
    variant: n,
    disabled: r,
    multiple: i,
    open: p,
    error: a
  } = o, d = {
    select: ["select", n, r && "disabled", i && "multiple", a && "error"],
    icon: ["icon", `icon${z(n)}`, p && "iconOpen", r && "disabled"],
    nativeInput: ["nativeInput"]
  };
  return V(d, Lo, t);
}, Ze = /* @__PURE__ */ u.forwardRef(function(t, n) {
  var De;
  const {
    "aria-describedby": r,
    "aria-label": i,
    autoFocus: p,
    autoWidth: a,
    children: d,
    className: m,
    defaultOpen: g,
    defaultValue: f,
    disabled: c,
    displayEmpty: O,
    error: R = !1,
    IconComponent: w,
    inputRef: T,
    labelId: y,
    MenuProps: x = {},
    multiple: C,
    name: I,
    onBlur: N,
    onChange: L,
    onClose: Y,
    onFocus: be,
    onOpen: Z,
    open: J,
    readOnly: Q,
    renderValue: ee,
    SelectDisplayProps: B = {},
    tabIndex: $,
    // catching `type` from Input which makes no sense for SelectInput
    type: q,
    value: oe,
    variant: Fe = "standard",
    ..._
  } = t, [b, te] = Ve({
    controlled: oe,
    default: f,
    name: "Select"
  }), [Me, eo] = Ve({
    controlled: J,
    default: g,
    name: "Select"
  }), je = u.useRef(null), F = u.useRef(null), [M, oo] = u.useState(null), {
    current: me
  } = u.useRef(J != null), [to, Le] = u.useState(), no = Xe(n, T), ro = u.useCallback((s) => {
    F.current = s, s && oo(s);
  }, []), ne = M == null ? void 0 : M.parentNode;
  u.useImperativeHandle(no, () => ({
    focus: () => {
      F.current.focus();
    },
    node: je.current,
    value: b
  }), [b]), u.useEffect(() => {
    g && Me && M && !me && (Le(a ? null : ne.clientWidth), F.current.focus());
  }, [M, a]), u.useEffect(() => {
    p && F.current.focus();
  }, [p]), u.useEffect(() => {
    if (!y)
      return;
    const s = Oo(F.current).getElementById(y);
    if (s) {
      const l = () => {
        getSelection().isCollapsed && F.current.focus();
      };
      return s.addEventListener("click", l), () => {
        s.removeEventListener("click", l);
      };
    }
  }, [y]);
  const re = (s, l) => {
    s ? Z && Z(l) : Y && Y(l), me || (Le(a ? null : ne.clientWidth), eo(s));
  }, so = (s) => {
    s.button === 0 && (s.preventDefault(), F.current.focus(), re(!0, s));
  }, ao = (s) => {
    re(!1, s);
  }, se = u.Children.toArray(d), io = (s) => {
    const l = se.find((S) => S.props.value === s.target.value);
    l !== void 0 && (te(l.props.value), L && L(s, l));
  }, lo = (s) => (l) => {
    let S;
    if (l.currentTarget.hasAttribute("tabindex")) {
      if (C) {
        S = Array.isArray(b) ? b.slice() : [];
        const A = b.indexOf(s.props.value);
        A === -1 ? S.push(s.props.value) : S.splice(A, 1);
      } else
        S = s.props.value;
      if (s.props.onClick && s.props.onClick(l), b !== S && (te(S), L)) {
        const A = l.nativeEvent || l, ze = new A.constructor(A.type, A);
        Object.defineProperty(ze, "target", {
          writable: !0,
          value: {
            value: S,
            name: I
          }
        }), L(ze, s);
      }
      C || re(!1, l);
    }
  }, po = (s) => {
    Q || [
      " ",
      "ArrowUp",
      "ArrowDown",
      // The native select doesn't respond to enter on macOS, but it's recommended by
      // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
      "Enter"
    ].includes(s.key) && (s.preventDefault(), re(!0, s));
  }, ae = M !== null && Me, uo = (s) => {
    !ae && N && (Object.defineProperty(s, "target", {
      writable: !0,
      value: {
        value: b,
        name: I
      }
    }), N(s));
  };
  delete _["aria-invalid"];
  let W, Be;
  const ie = [];
  let le = !1, ge = !1;
  (ho({
    value: b
  }) || O) && (ee ? W = ee(b) : le = !0);
  const co = se.map((s) => {
    if (!/* @__PURE__ */ u.isValidElement(s))
      return null;
    process.env.NODE_ENV !== "production" && mo.isFragment(s) && console.error(["MUI: The Select component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`));
    let l;
    if (C) {
      if (!Array.isArray(b))
        throw new Error(process.env.NODE_ENV !== "production" ? "MUI: The `value` prop must be an array when using the `Select` component with `multiple`." : fo(2));
      l = b.some((S) => _e(S, s.props.value)), l && le && ie.push(s.props.children);
    } else
      l = _e(b, s.props.value), l && le && (Be = s.props.children);
    return l && (ge = !0), /* @__PURE__ */ u.cloneElement(s, {
      "aria-selected": l ? "true" : "false",
      onClick: lo(s),
      onKeyUp: (S) => {
        S.key === " " && S.preventDefault(), s.props.onKeyUp && s.props.onKeyUp(S);
      },
      role: "option",
      selected: l,
      value: void 0,
      // The value is most likely not a valid HTML attribute.
      "data-value": s.props.value
      // Instead, we provide it as a data attribute.
    });
  });
  process.env.NODE_ENV !== "production" && u.useEffect(() => {
    if (!ge && !C && b !== "") {
      const s = se.map((l) => l.props.value);
      console.warn([`MUI: You have provided an out-of-range value \`${b}\` for the select ${I ? `(name="${I}") ` : ""}component.`, "Consider providing a value that matches one of the available options or ''.", `The available values are ${s.filter((l) => l != null).map((l) => `\`${l}\``).join(", ") || '""'}.`].join(`
`));
    }
  }, [ge, se, C, I, b]), le && (C ? ie.length === 0 ? W = null : W = ie.reduce((s, l, S) => (s.push(l), S < ie.length - 1 && s.push(", "), s), []) : W = Be);
  let We = to;
  !a && me && M && (We = ne.clientWidth);
  let ve;
  typeof $ < "u" ? ve = $ : ve = c ? null : 0;
  const Ae = B.id || (I ? `mui-component-select-${I}` : void 0), pe = {
    ...t,
    variant: Fe,
    value: b,
    open: ae,
    error: R
  }, ye = Do(pe), he = {
    ...x.PaperProps,
    ...(De = x.slotProps) == null ? void 0 : De.paper
  }, Ue = Co();
  return /* @__PURE__ */ Se(u.Fragment, {
    children: [/* @__PURE__ */ v(Bo, {
      as: "div",
      ref: ro,
      tabIndex: ve,
      role: "combobox",
      "aria-controls": Ue,
      "aria-disabled": c ? "true" : void 0,
      "aria-expanded": ae ? "true" : "false",
      "aria-haspopup": "listbox",
      "aria-label": i,
      "aria-labelledby": [y, Ae].filter(Boolean).join(" ") || void 0,
      "aria-describedby": r,
      onKeyDown: po,
      onMouseDown: c || Q ? null : so,
      onBlur: uo,
      onFocus: be,
      ...B,
      ownerState: pe,
      className: fe(B.className, ye.select, m),
      id: Ae,
      children: Uo(W) ? (
        // notranslate needed while Google Translate will not fix zero-width space issue
        qe || (qe = /* @__PURE__ */ v("span", {
          className: "notranslate",
          children: "​"
        }))
      ) : W
    }), /* @__PURE__ */ v(Ao, {
      "aria-invalid": R,
      value: Array.isArray(b) ? b.join(",") : b,
      name: I,
      ref: je,
      "aria-hidden": !0,
      onChange: io,
      tabIndex: -1,
      disabled: c,
      className: ye.nativeInput,
      autoFocus: p,
      ..._,
      ownerState: pe
    }), /* @__PURE__ */ v(Wo, {
      as: w,
      className: ye.icon,
      ownerState: pe
    }), /* @__PURE__ */ v(yo, {
      id: `menu-${I || ""}`,
      anchorEl: ne,
      open: ae,
      onClose: ao,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "center"
      },
      transformOrigin: {
        vertical: "top",
        horizontal: "center"
      },
      ...x,
      MenuListProps: {
        "aria-labelledby": y,
        role: "listbox",
        "aria-multiselectable": C ? "true" : void 0,
        disableListWrap: !0,
        id: Ue,
        ...x.MenuListProps
      },
      slotProps: {
        ...x.slotProps,
        paper: {
          ...he,
          style: {
            minWidth: We,
            ...he != null ? he.style : null
          }
        }
      },
      children: co
    })]
  });
});
process.env.NODE_ENV !== "production" && (Ze.propTypes = {
  /**
   * @ignore
   */
  "aria-describedby": e.string,
  /**
   * @ignore
   */
  "aria-label": e.string,
  /**
   * @ignore
   */
  autoFocus: e.bool,
  /**
   * If `true`, the width of the popover will automatically be set according to the items inside the
   * menu, otherwise it will be at least the width of the select input.
   */
  autoWidth: e.bool,
  /**
   * The option elements to populate the select with.
   * Can be some `<MenuItem>` elements.
   */
  children: e.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: e.object,
  /**
   * The CSS class name of the select element.
   */
  className: e.string,
  /**
   * If `true`, the component is toggled on mount. Use when the component open state is not controlled.
   * You can only use it when the `native` prop is `false` (default).
   */
  defaultOpen: e.bool,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: e.any,
  /**
   * If `true`, the select is disabled.
   */
  disabled: e.bool,
  /**
   * If `true`, the selected item is displayed even if its value is empty.
   */
  displayEmpty: e.bool,
  /**
   * If `true`, the `select input` will indicate an error.
   */
  error: e.bool,
  /**
   * The icon that displays the arrow.
   */
  IconComponent: e.elementType.isRequired,
  /**
   * Imperative handle implementing `{ value: T, node: HTMLElement, focus(): void }`
   * Equivalent to `ref`
   */
  inputRef: G,
  /**
   * The ID of an element that acts as an additional label. The Select will
   * be labelled by the additional label and the selected value.
   */
  labelId: e.string,
  /**
   * Props applied to the [`Menu`](/material-ui/api/menu/) element.
   */
  MenuProps: e.object,
  /**
   * If `true`, `value` must be an array and the menu will support multiple selections.
   */
  multiple: e.bool,
  /**
   * Name attribute of the `select` or hidden `input` element.
   */
  name: e.string,
  /**
   * @ignore
   */
  onBlur: e.func,
  /**
   * Callback fired when a menu item is selected.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (any).
   * @param {object} [child] The react element that was selected.
   */
  onChange: e.func,
  /**
   * Callback fired when the component requests to be closed.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */
  onClose: e.func,
  /**
   * @ignore
   */
  onFocus: e.func,
  /**
   * Callback fired when the component requests to be opened.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */
  onOpen: e.func,
  /**
   * If `true`, the component is shown.
   */
  open: e.bool,
  /**
   * @ignore
   */
  readOnly: e.bool,
  /**
   * Render the selected value.
   *
   * @param {any} value The `value` provided to the component.
   * @returns {ReactNode}
   */
  renderValue: e.func,
  /**
   * Props applied to the clickable div element.
   */
  SelectDisplayProps: e.object,
  /**
   * @ignore
   */
  tabIndex: e.oneOfType([e.number, e.string]),
  /**
   * @ignore
   */
  type: e.any,
  /**
   * The input value.
   */
  value: e.any,
  /**
   * The variant to use.
   */
  variant: e.oneOf(["standard", "outlined", "filled"])
});
const zo = Io(/* @__PURE__ */ v("path", {
  d: "M7 10l5 5 5-5z"
}), "ArrowDropDown");
function Vo(o) {
  return U("MuiFilledInput", o);
}
const j = {
  ...xe,
  ...D("MuiFilledInput", ["root", "underline", "input", "adornedStart", "adornedEnd", "sizeSmall", "multiline", "hiddenLabel"])
}, qo = (o) => {
  const {
    classes: t,
    disableUnderline: n,
    startAdornment: r,
    endAdornment: i,
    size: p,
    hiddenLabel: a,
    multiline: d
  } = o, m = {
    root: ["root", !n && "underline", r && "adornedStart", i && "adornedEnd", p === "small" && `size${z(p)}`, a && "hiddenLabel", d && "multiline"],
    input: ["input"]
  }, g = V(m, Vo, t);
  return {
    ...t,
    // forward classes to the InputBase
    ...g
  };
}, _o = h(we, {
  shouldForwardProp: (o) => k(o) || o === "classes",
  name: "MuiFilledInput",
  slot: "Root",
  overridesResolver: (o, t) => {
    const {
      ownerState: n
    } = o;
    return [...Te(o, t), !n.disableUnderline && t.underline];
  }
})(E(({
  theme: o
}) => {
  const t = o.palette.mode === "light", n = t ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)", r = t ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)", i = t ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)", p = t ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
  return {
    position: "relative",
    backgroundColor: o.vars ? o.vars.palette.FilledInput.bg : r,
    borderTopLeftRadius: (o.vars || o).shape.borderRadius,
    borderTopRightRadius: (o.vars || o).shape.borderRadius,
    transition: o.transitions.create("background-color", {
      duration: o.transitions.duration.shorter,
      easing: o.transitions.easing.easeOut
    }),
    "&:hover": {
      backgroundColor: o.vars ? o.vars.palette.FilledInput.hoverBg : i,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: o.vars ? o.vars.palette.FilledInput.bg : r
      }
    },
    [`&.${j.focused}`]: {
      backgroundColor: o.vars ? o.vars.palette.FilledInput.bg : r
    },
    [`&.${j.disabled}`]: {
      backgroundColor: o.vars ? o.vars.palette.FilledInput.disabledBg : p
    },
    variants: [{
      props: ({
        ownerState: a
      }) => !a.disableUnderline,
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: o.transitions.create("transform", {
            duration: o.transitions.duration.shorter,
            easing: o.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${j.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${j.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (o.vars || o).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${o.vars ? `rgba(${o.vars.palette.common.onBackgroundChannel} / ${o.vars.opacity.inputUnderline})` : n}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: o.transitions.create("border-bottom-color", {
            duration: o.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${j.disabled}, .${j.error}):before`]: {
          borderBottom: `1px solid ${(o.vars || o).palette.text.primary}`
        },
        [`&.${j.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, ...Object.entries(o.palette).filter(Re()).map(([a]) => {
      var d;
      return {
        props: {
          disableUnderline: !1,
          color: a
        },
        style: {
          "&::after": {
            borderBottom: `2px solid ${(d = (o.vars || o).palette[a]) == null ? void 0 : d.main}`
          }
        }
      };
    }), {
      props: ({
        ownerState: a
      }) => a.startAdornment,
      style: {
        paddingLeft: 12
      }
    }, {
      props: ({
        ownerState: a
      }) => a.endAdornment,
      style: {
        paddingRight: 12
      }
    }, {
      props: ({
        ownerState: a
      }) => a.multiline,
      style: {
        padding: "25px 12px 8px"
      }
    }, {
      props: ({
        ownerState: a,
        size: d
      }) => a.multiline && d === "small",
      style: {
        paddingTop: 21,
        paddingBottom: 4
      }
    }, {
      props: ({
        ownerState: a
      }) => a.multiline && a.hiddenLabel,
      style: {
        paddingTop: 16,
        paddingBottom: 17
      }
    }, {
      props: ({
        ownerState: a
      }) => a.multiline && a.hiddenLabel && a.size === "small",
      style: {
        paddingTop: 8,
        paddingBottom: 9
      }
    }]
  };
})), Ko = h(Ne, {
  name: "MuiFilledInput",
  slot: "Input",
  overridesResolver: Pe
})(E(({
  theme: o
}) => ({
  paddingTop: 25,
  paddingRight: 12,
  paddingBottom: 8,
  paddingLeft: 12,
  ...!o.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: o.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: o.palette.mode === "light" ? null : "#fff",
      caretColor: o.palette.mode === "light" ? null : "#fff",
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    }
  },
  ...o.vars && {
    "&:-webkit-autofill": {
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    },
    [o.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      paddingTop: 21,
      paddingBottom: 4
    }
  }, {
    props: ({
      ownerState: t
    }) => t.hiddenLabel,
    style: {
      paddingTop: 16,
      paddingBottom: 17
    }
  }, {
    props: ({
      ownerState: t
    }) => t.startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.endAdornment,
    style: {
      paddingRight: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.hiddenLabel && t.size === "small",
    style: {
      paddingTop: 8,
      paddingBottom: 9
    }
  }, {
    props: ({
      ownerState: t
    }) => t.multiline,
    style: {
      paddingTop: 0,
      paddingBottom: 0,
      paddingLeft: 0,
      paddingRight: 0
    }
  }]
}))), ue = /* @__PURE__ */ u.forwardRef(function(t, n) {
  const r = H({
    props: t,
    name: "MuiFilledInput"
  }), {
    disableUnderline: i = !1,
    components: p = {},
    componentsProps: a,
    fullWidth: d = !1,
    hiddenLabel: m,
    // declare here to prevent spreading to DOM
    inputComponent: g = "input",
    multiline: f = !1,
    slotProps: c,
    slots: O = {},
    type: R = "text",
    ...w
  } = r, T = {
    ...r,
    disableUnderline: i,
    fullWidth: d,
    inputComponent: g,
    multiline: f,
    type: R
  }, y = qo(r), x = {
    root: {
      ownerState: T
    },
    input: {
      ownerState: T
    }
  }, C = c ?? a ? Oe(x, c ?? a) : x, I = O.root ?? p.Root ?? _o, N = O.input ?? p.Input ?? Ko;
  return /* @__PURE__ */ v($e, {
    slots: {
      root: I,
      input: N
    },
    componentsProps: C,
    fullWidth: d,
    inputComponent: g,
    multiline: f,
    ref: n,
    type: R,
    ...w,
    classes: y
  });
});
process.env.NODE_ENV !== "production" && (ue.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: e.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: e.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: e.object,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: e.oneOfType([e.oneOf(["primary", "secondary"]), e.string]),
  /**
   * The components used for each slot inside.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  components: e.shape({
    Input: e.elementType,
    Root: e.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @deprecated use the `slotProps` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  componentsProps: e.shape({
    input: e.object,
    root: e.object
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: e.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: e.bool,
  /**
   * If `true`, the input will not have an underline.
   * @default false
   */
  disableUnderline: e.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: e.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: e.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: e.bool,
  /**
   * If `true`, the label is hidden.
   * This is used to increase density for a `FilledInput`.
   * Be sure to add `aria-label` to the `input` element.
   * @default false
   */
  hiddenLabel: e.bool,
  /**
   * The id of the `input` element.
   */
  id: e.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: e.elementType,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: e.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: G,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: e.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: e.oneOfType([e.number, e.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: e.oneOfType([e.number, e.string]),
  /**
   * If `true`, a [TextareaAutosize](https://mui.com/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: e.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: e.string,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: e.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: e.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: e.bool,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: e.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: e.oneOfType([e.number, e.string]),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: e.shape({
    input: e.object,
    root: e.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: e.shape({
    input: e.elementType,
    root: e.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: e.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: e.oneOfType([e.arrayOf(e.oneOfType([e.func, e.object, e.bool])), e.func, e.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   * @default 'text'
   */
  type: e.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: e.any
});
ue && (ue.muiName = "Input");
var Ke;
const Xo = h("fieldset", {
  shouldForwardProp: k
})({
  textAlign: "left",
  position: "absolute",
  bottom: 0,
  right: 0,
  top: -5,
  left: 0,
  margin: 0,
  padding: "0 8px",
  pointerEvents: "none",
  borderRadius: "inherit",
  borderStyle: "solid",
  borderWidth: 1,
  overflow: "hidden",
  minWidth: "0%"
}), Ho = h("legend", {
  shouldForwardProp: k
})(E(({
  theme: o
}) => ({
  float: "unset",
  // Fix conflict with bootstrap
  width: "auto",
  // Fix conflict with bootstrap
  overflow: "hidden",
  // Fix Horizontal scroll when label too long
  variants: [{
    props: ({
      ownerState: t
    }) => !t.withLabel,
    style: {
      padding: 0,
      lineHeight: "11px",
      // sync with `height` in `legend` styles
      transition: o.transitions.create("width", {
        duration: 150,
        easing: o.transitions.easing.easeOut
      })
    }
  }, {
    props: ({
      ownerState: t
    }) => t.withLabel,
    style: {
      display: "block",
      // Fix conflict with normalize.css and sanitize.css
      padding: 0,
      height: 11,
      // sync with `lineHeight` in `legend` styles
      fontSize: "0.75em",
      visibility: "hidden",
      maxWidth: 0.01,
      transition: o.transitions.create("max-width", {
        duration: 50,
        easing: o.transitions.easing.easeOut
      }),
      whiteSpace: "nowrap",
      "& > span": {
        paddingLeft: 5,
        paddingRight: 5,
        display: "inline-block",
        opacity: 0,
        visibility: "visible"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.withLabel && t.notched,
    style: {
      maxWidth: "100%",
      transition: o.transitions.create("max-width", {
        duration: 100,
        easing: o.transitions.easing.easeOut,
        delay: 50
      })
    }
  }]
})));
function Je(o) {
  const {
    children: t,
    classes: n,
    className: r,
    label: i,
    notched: p,
    ...a
  } = o, d = i != null && i !== "", m = {
    ...o,
    notched: p,
    withLabel: d
  };
  return /* @__PURE__ */ v(Xo, {
    "aria-hidden": !0,
    className: r,
    ownerState: m,
    ...a,
    children: /* @__PURE__ */ v(Ho, {
      ownerState: m,
      children: d ? /* @__PURE__ */ v("span", {
        children: i
      }) : (
        // notranslate needed while Google Translate will not fix zero-width space issue
        Ke || (Ke = /* @__PURE__ */ v("span", {
          className: "notranslate",
          children: "​"
        }))
      )
    })
  });
}
process.env.NODE_ENV !== "production" && (Je.propTypes = {
  /**
   * The content of the component.
   */
  children: e.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: e.object,
  /**
   * @ignore
   */
  className: e.string,
  /**
   * The label.
   */
  label: e.node,
  /**
   * If `true`, the outline is notched to accommodate the label.
   */
  notched: e.bool.isRequired,
  /**
   * @ignore
   */
  style: e.object
});
function Go(o) {
  return U("MuiOutlinedInput", o);
}
const P = {
  ...xe,
  ...D("MuiOutlinedInput", ["root", "notchedOutline", "input"])
}, Yo = (o) => {
  const {
    classes: t
  } = o, r = V({
    root: ["root"],
    notchedOutline: ["notchedOutline"],
    input: ["input"]
  }, Go, t);
  return {
    ...t,
    // forward classes to the InputBase
    ...r
  };
}, Zo = h(we, {
  shouldForwardProp: (o) => k(o) || o === "classes",
  name: "MuiOutlinedInput",
  slot: "Root",
  overridesResolver: Te
})(E(({
  theme: o
}) => {
  const t = o.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    position: "relative",
    borderRadius: (o.vars || o).shape.borderRadius,
    [`&:hover .${P.notchedOutline}`]: {
      borderColor: (o.vars || o).palette.text.primary
    },
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      [`&:hover .${P.notchedOutline}`]: {
        borderColor: o.vars ? `rgba(${o.vars.palette.common.onBackgroundChannel} / 0.23)` : t
      }
    },
    [`&.${P.focused} .${P.notchedOutline}`]: {
      borderWidth: 2
    },
    variants: [...Object.entries(o.palette).filter(Re()).map(([n]) => ({
      props: {
        color: n
      },
      style: {
        [`&.${P.focused} .${P.notchedOutline}`]: {
          borderColor: (o.vars || o).palette[n].main
        }
      }
    })), {
      props: {},
      // to overide the above style
      style: {
        [`&.${P.error} .${P.notchedOutline}`]: {
          borderColor: (o.vars || o).palette.error.main
        },
        [`&.${P.disabled} .${P.notchedOutline}`]: {
          borderColor: (o.vars || o).palette.action.disabled
        }
      }
    }, {
      props: ({
        ownerState: n
      }) => n.startAdornment,
      style: {
        paddingLeft: 14
      }
    }, {
      props: ({
        ownerState: n
      }) => n.endAdornment,
      style: {
        paddingRight: 14
      }
    }, {
      props: ({
        ownerState: n
      }) => n.multiline,
      style: {
        padding: "16.5px 14px"
      }
    }, {
      props: ({
        ownerState: n,
        size: r
      }) => n.multiline && r === "small",
      style: {
        padding: "8.5px 14px"
      }
    }]
  };
})), Jo = h(Je, {
  name: "MuiOutlinedInput",
  slot: "NotchedOutline",
  overridesResolver: (o, t) => t.notchedOutline
})(E(({
  theme: o
}) => {
  const t = o.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    borderColor: o.vars ? `rgba(${o.vars.palette.common.onBackgroundChannel} / 0.23)` : t
  };
})), Qo = h(Ne, {
  name: "MuiOutlinedInput",
  slot: "Input",
  overridesResolver: Pe
})(E(({
  theme: o
}) => ({
  padding: "16.5px 14px",
  ...!o.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: o.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: o.palette.mode === "light" ? null : "#fff",
      caretColor: o.palette.mode === "light" ? null : "#fff",
      borderRadius: "inherit"
    }
  },
  ...o.vars && {
    "&:-webkit-autofill": {
      borderRadius: "inherit"
    },
    [o.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      padding: "8.5px 14px"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.multiline,
    style: {
      padding: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.endAdornment,
    style: {
      paddingRight: 0
    }
  }]
}))), ce = /* @__PURE__ */ u.forwardRef(function(t, n) {
  var r;
  const i = H({
    props: t,
    name: "MuiOutlinedInput"
  }), {
    components: p = {},
    fullWidth: a = !1,
    inputComponent: d = "input",
    label: m,
    multiline: g = !1,
    notched: f,
    slots: c = {},
    type: O = "text",
    ...R
  } = i, w = Yo(i), T = Ie(), y = Ce({
    props: i,
    muiFormControl: T,
    states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
  }), x = {
    ...i,
    color: y.color || "primary",
    disabled: y.disabled,
    error: y.error,
    focused: y.focused,
    formControl: T,
    fullWidth: a,
    hiddenLabel: y.hiddenLabel,
    multiline: g,
    size: y.size,
    type: O
  }, C = c.root ?? p.Root ?? Zo, I = c.input ?? p.Input ?? Qo;
  return /* @__PURE__ */ v($e, {
    slots: {
      root: C,
      input: I
    },
    renderSuffix: (N) => /* @__PURE__ */ v(Jo, {
      ownerState: x,
      className: w.notchedOutline,
      label: m != null && m !== "" && y.required ? r || (r = /* @__PURE__ */ Se(u.Fragment, {
        children: [m, " ", "*"]
      })) : m,
      notched: typeof f < "u" ? f : !!(N.startAdornment || N.filled || N.focused)
    }),
    fullWidth: a,
    inputComponent: d,
    multiline: g,
    ref: n,
    type: O,
    ...R,
    classes: {
      ...w,
      notchedOutline: null
    }
  });
});
process.env.NODE_ENV !== "production" && (ce.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: e.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: e.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: e.object,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: e.oneOfType([e.oneOf(["primary", "secondary"]), e.string]),
  /**
   * The components used for each slot inside.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  components: e.shape({
    Input: e.elementType,
    Root: e.elementType
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: e.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: e.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: e.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: e.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: e.bool,
  /**
   * The id of the `input` element.
   */
  id: e.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: e.elementType,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: e.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: G,
  /**
   * The label of the `input`. It is only used for layout. The actual labelling
   * is handled by `InputLabel`.
   */
  label: e.node,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: e.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: e.oneOfType([e.number, e.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: e.oneOfType([e.number, e.string]),
  /**
   * If `true`, a [TextareaAutosize](https://mui.com/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: e.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: e.string,
  /**
   * If `true`, the outline is notched to accommodate the label.
   */
  notched: e.bool,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: e.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: e.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: e.bool,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: e.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: e.oneOfType([e.number, e.string]),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: e.shape({
    input: e.elementType,
    root: e.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: e.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: e.oneOfType([e.arrayOf(e.oneOfType([e.func, e.object, e.bool])), e.func, e.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   * @default 'text'
   */
  type: e.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: e.any
});
ce && (ce.muiName = "Input");
const et = (o) => {
  const {
    classes: t
  } = o;
  return t;
}, Ee = {
  name: "MuiSelect",
  overridesResolver: (o, t) => t.root,
  shouldForwardProp: (o) => k(o) && o !== "variant",
  slot: "Root"
}, ot = h(de, Ee)(""), tt = h(ce, Ee)(""), nt = h(ue, Ee)(""), Qe = /* @__PURE__ */ u.forwardRef(function(t, n) {
  const r = H({
    name: "MuiSelect",
    props: t
  }), {
    autoWidth: i = !1,
    children: p,
    classes: a = {},
    className: d,
    defaultOpen: m = !1,
    displayEmpty: g = !1,
    IconComponent: f = zo,
    id: c,
    input: O,
    inputProps: R,
    label: w,
    labelId: T,
    MenuProps: y,
    multiple: x = !1,
    native: C = !1,
    onClose: I,
    onOpen: N,
    open: L,
    renderValue: Y,
    SelectDisplayProps: be,
    variant: Z = "outlined",
    ...J
  } = r, Q = C ? Ye : Ze, ee = Ie(), B = Ce({
    props: r,
    muiFormControl: ee,
    states: ["variant", "error"]
  }), $ = B.variant || Z, q = {
    ...r,
    variant: $,
    classes: a
  }, oe = et(q), {
    root: Fe,
    ..._
  } = oe, b = O || {
    standard: /* @__PURE__ */ v(ot, {
      ownerState: q
    }),
    outlined: /* @__PURE__ */ v(tt, {
      label: w,
      ownerState: q
    }),
    filled: /* @__PURE__ */ v(nt, {
      ownerState: q
    })
  }[$], te = Xe(n, So(b));
  return /* @__PURE__ */ v(u.Fragment, {
    children: /* @__PURE__ */ u.cloneElement(b, {
      // Most of the logic is implemented in `SelectInput`.
      // The `Select` component is a simple API wrapper to expose something better to play with.
      inputComponent: Q,
      inputProps: {
        children: p,
        error: B.error,
        IconComponent: f,
        variant: $,
        type: void 0,
        // We render a select. We can ignore the type provided by the `Input`.
        multiple: x,
        ...C ? {
          id: c
        } : {
          autoWidth: i,
          defaultOpen: m,
          displayEmpty: g,
          labelId: T,
          MenuProps: y,
          onClose: I,
          onOpen: N,
          open: L,
          renderValue: Y,
          SelectDisplayProps: {
            id: c,
            ...be
          }
        },
        ...R,
        classes: R ? Oe(_, R.classes) : _,
        ...O ? O.props.inputProps : {}
      },
      ...(x && C || g) && $ === "outlined" ? {
        notched: !0
      } : {},
      ref: te,
      className: fe(b.props.className, d, oe.root),
      // If a custom input is provided via 'input' prop, do not allow 'variant' to be propagated to it's root element. See https://github.com/mui/material-ui/issues/33894.
      ...!O && {
        variant: $
      },
      ...J
    })
  });
});
process.env.NODE_ENV !== "production" && (Qe.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * If `true`, the width of the popover will automatically be set according to the items inside the
   * menu, otherwise it will be at least the width of the select input.
   * @default false
   */
  autoWidth: e.bool,
  /**
   * The option elements to populate the select with.
   * Can be some `MenuItem` when `native` is false and `option` when `native` is true.
   *
   * ⚠️The `MenuItem` elements **must** be direct descendants when `native` is false.
   */
  children: e.node,
  /**
   * Override or extend the styles applied to the component.
   * @default {}
   */
  classes: e.object,
  /**
   * @ignore
   */
  className: e.string,
  /**
   * If `true`, the component is initially open. Use when the component open state is not controlled (i.e. the `open` prop is not defined).
   * You can only use it when the `native` prop is `false` (default).
   * @default false
   */
  defaultOpen: e.bool,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: e.any,
  /**
   * If `true`, a value is displayed even if no items are selected.
   *
   * In order to display a meaningful value, a function can be passed to the `renderValue` prop which
   * returns the value to be displayed when no items are selected.
   *
   * ⚠️ When using this prop, make sure the label doesn't overlap with the empty displayed value.
   * The label should either be hidden or forced to a shrunk state.
   * @default false
   */
  displayEmpty: e.bool,
  /**
   * The icon that displays the arrow.
   * @default ArrowDropDownIcon
   */
  IconComponent: e.elementType,
  /**
   * The `id` of the wrapper element or the `select` element when `native`.
   */
  id: e.string,
  /**
   * An `Input` element; does not have to be a material-ui specific `Input`.
   */
  input: e.element,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * When `native` is `true`, the attributes are applied on the `select` element.
   */
  inputProps: e.object,
  /**
   * See [OutlinedInput#label](https://mui.com/material-ui/api/outlined-input/#props)
   */
  label: e.node,
  /**
   * The ID of an element that acts as an additional label. The Select will
   * be labelled by the additional label and the selected value.
   */
  labelId: e.string,
  /**
   * Props applied to the [`Menu`](https://mui.com/material-ui/api/menu/) element.
   */
  MenuProps: e.object,
  /**
   * If `true`, `value` must be an array and the menu will support multiple selections.
   * @default false
   */
  multiple: e.bool,
  /**
   * If `true`, the component uses a native `select` element.
   * @default false
   */
  native: e.bool,
  /**
   * Callback fired when a menu item is selected.
   *
   * @param {SelectChangeEvent<Value>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (any).
   * **Warning**: This is a generic event, not a change event, unless the change event is caused by browser autofill.
   * @param {object} [child] The react element that was selected when `native` is `false` (default).
   */
  onChange: e.func,
  /**
   * Callback fired when the component requests to be closed.
   * Use it in either controlled (see the `open` prop), or uncontrolled mode (to detect when the Select collapses).
   *
   * @param {object} event The event source of the callback.
   */
  onClose: e.func,
  /**
   * Callback fired when the component requests to be opened.
   * Use it in either controlled (see the `open` prop), or uncontrolled mode (to detect when the Select expands).
   *
   * @param {object} event The event source of the callback.
   */
  onOpen: e.func,
  /**
   * If `true`, the component is shown.
   * You can only use it when the `native` prop is `false` (default).
   */
  open: e.bool,
  /**
   * Render the selected value.
   * You can only use it when the `native` prop is `false` (default).
   *
   * @param {any} value The `value` provided to the component.
   * @returns {ReactNode}
   */
  renderValue: e.func,
  /**
   * Props applied to the clickable div element.
   */
  SelectDisplayProps: e.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: e.oneOfType([e.arrayOf(e.oneOfType([e.func, e.object, e.bool])), e.func, e.object]),
  /**
   * The `input` value. Providing an empty string will select no options.
   * Set to an empty string `''` if you don't want any of the available options to be selected.
   *
   * If the value is an object it must have reference equality with the option in order to be selected.
   * If the value is not an object, the string representation must match with the string representation of the option in order to be selected.
   */
  value: e.oneOfType([e.oneOf([""]), e.any]),
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: e.oneOf(["filled", "outlined", "standard"])
});
Qe.muiName = "Select";
export {
  ue as F,
  de as I,
  ce as O,
  Qe as S,
  ko as a,
  It as b,
  No as c,
  Lo as d,
  Ro as g,
  K as i,
  X as s
};
