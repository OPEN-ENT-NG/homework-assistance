import * as u from "react";
import { P as n, I as me, H as he, G as Z } from "./identifier-B7MO0PvI.js";
import { m as ge } from "./memoTheme-CqfvfBST.js";
import { o as z } from "./ownerWindow-niciwP7I.js";
import { o as A } from "./ownerDocument-CUrv0DIK.js";
import { u as Y } from "./useForkRef-C_4o__cU.js";
import { a as ee } from "./useTimeout-Znm_nF2D.js";
import { e as Ee } from "./resolveComponentProps-CYk57pLv.js";
import { c as te } from "./createChainedFunction-C0nujS3O.js";
import { u as oe } from "./useSlot-BSVkAc2J.js";
import { jsxs as se, jsx as j } from "react/jsx-runtime";
import { s as ie, u as Te, c as ye } from "./DefaultPropsProvider-BYFwNPLt.js";
import { B as Re } from "./Backdrop-DcJf9G30.js";
import { e as xe, P as ke, H as ve } from "./Portal-meM40OhI.js";
import { g as Pe, e as ce } from "./utils-jA5a7WHN.js";
function Ie(e = window) {
  const t = e.document.documentElement.clientWidth;
  return e.innerWidth - t;
}
function Ne(e) {
  const t = A(e);
  return t.body === e ? z(e).innerWidth > t.documentElement.clientWidth : e.scrollHeight > e.clientHeight;
}
function K(e, t) {
  t ? e.setAttribute("aria-hidden", "true") : e.removeAttribute("aria-hidden");
}
function ne(e) {
  return parseInt(z(e).getComputedStyle(e).paddingRight, 10) || 0;
}
function Se(e) {
  const s = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"].includes(e.tagName), o = e.tagName === "INPUT" && e.getAttribute("type") === "hidden";
  return s || o;
}
function re(e, t, s, o, i) {
  const r = [t, s, ...o];
  [].forEach.call(e.children, (c) => {
    const a = !r.includes(c), b = !Se(c);
    a && b && K(c, i);
  });
}
function $(e, t) {
  let s = -1;
  return e.some((o, i) => t(o) ? (s = i, !0) : !1), s;
}
function Ce(e, t) {
  const s = [], o = e.container;
  if (!t.disableScrollLock) {
    if (Ne(o)) {
      const c = Ie(z(o));
      s.push({
        value: o.style.paddingRight,
        property: "padding-right",
        el: o
      }), o.style.paddingRight = `${ne(o) + c}px`;
      const a = A(o).querySelectorAll(".mui-fixed");
      [].forEach.call(a, (b) => {
        s.push({
          value: b.style.paddingRight,
          property: "padding-right",
          el: b
        }), b.style.paddingRight = `${ne(b) + c}px`;
      });
    }
    let r;
    if (o.parentNode instanceof DocumentFragment)
      r = A(o).body;
    else {
      const c = o.parentElement, a = z(o);
      r = (c == null ? void 0 : c.nodeName) === "HTML" && a.getComputedStyle(c).overflowY === "scroll" ? c : o;
    }
    s.push({
      value: r.style.overflow,
      property: "overflow",
      el: r
    }, {
      value: r.style.overflowX,
      property: "overflow-x",
      el: r
    }, {
      value: r.style.overflowY,
      property: "overflow-y",
      el: r
    }), r.style.overflow = "hidden";
  }
  return () => {
    s.forEach(({
      value: r,
      el: c,
      property: a
    }) => {
      r ? c.style.setProperty(a, r) : c.style.removeProperty(a);
    });
  };
}
function Fe(e) {
  const t = [];
  return [].forEach.call(e.children, (s) => {
    s.getAttribute("aria-hidden") === "true" && t.push(s);
  }), t;
}
class Me {
  constructor() {
    this.modals = [], this.containers = [];
  }
  add(t, s) {
    let o = this.modals.indexOf(t);
    if (o !== -1)
      return o;
    o = this.modals.length, this.modals.push(t), t.modalRef && K(t.modalRef, !1);
    const i = Fe(s);
    re(s, t.mount, t.modalRef, i, !0);
    const r = $(this.containers, (c) => c.container === s);
    return r !== -1 ? (this.containers[r].modals.push(t), o) : (this.containers.push({
      modals: [t],
      container: s,
      restore: null,
      hiddenSiblings: i
    }), o);
  }
  mount(t, s) {
    const o = $(this.containers, (r) => r.modals.includes(t)), i = this.containers[o];
    i.restore || (i.restore = Ce(i, s));
  }
  remove(t, s = !0) {
    const o = this.modals.indexOf(t);
    if (o === -1)
      return o;
    const i = $(this.containers, (c) => c.modals.includes(t)), r = this.containers[i];
    if (r.modals.splice(r.modals.indexOf(t), 1), this.modals.splice(o, 1), r.modals.length === 0)
      r.restore && r.restore(), t.modalRef && K(t.modalRef, s), re(r.container, t.mount, t.modalRef, r.hiddenSiblings, !1), this.containers.splice(i, 1);
    else {
      const c = r.modals[r.modals.length - 1];
      c.modalRef && K(c.modalRef, !1);
    }
    return o;
  }
  isTopModal(t) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === t;
  }
}
const Oe = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function we(e) {
  const t = parseInt(e.getAttribute("tabindex") || "", 10);
  return Number.isNaN(t) ? e.contentEditable === "true" || (e.nodeName === "AUDIO" || e.nodeName === "VIDEO" || e.nodeName === "DETAILS") && e.getAttribute("tabindex") === null ? 0 : e.tabIndex : t;
}
function Ae(e) {
  if (e.tagName !== "INPUT" || e.type !== "radio" || !e.name)
    return !1;
  const t = (o) => e.ownerDocument.querySelector(`input[type="radio"]${o}`);
  let s = t(`[name="${e.name}"]:checked`);
  return s || (s = t(`[name="${e.name}"]`)), s !== e;
}
function De(e) {
  return !(e.disabled || e.tagName === "INPUT" && e.type === "hidden" || Ae(e));
}
function Be(e) {
  const t = [], s = [];
  return Array.from(e.querySelectorAll(Oe)).forEach((o, i) => {
    const r = we(o);
    r === -1 || !De(o) || (r === 0 ? t.push(o) : s.push({
      documentOrder: i,
      tabIndex: r,
      node: o
    }));
  }), s.sort((o, i) => o.tabIndex === i.tabIndex ? o.documentOrder - i.documentOrder : o.tabIndex - i.tabIndex).map((o) => o.node).concat(t);
}
function Le() {
  return !0;
}
function V(e) {
  const {
    children: t,
    disableAutoFocus: s = !1,
    disableEnforceFocus: o = !1,
    disableRestoreFocus: i = !1,
    getTabbable: r = Be,
    isEnabled: c = Le,
    open: a
  } = e, b = u.useRef(!1), E = u.useRef(null), k = u.useRef(null), h = u.useRef(null), y = u.useRef(null), m = u.useRef(!1), p = u.useRef(null), w = Y(Pe(t), p), N = u.useRef(null);
  u.useEffect(() => {
    !a || !p.current || (m.current = !s);
  }, [s, a]), u.useEffect(() => {
    if (!a || !p.current)
      return;
    const l = A(p.current);
    return p.current.contains(l.activeElement) || (p.current.hasAttribute("tabIndex") || (process.env.NODE_ENV !== "production" && console.error(["MUI: The modal content node does not accept focus.", 'For the benefit of assistive technologies, the tabIndex of the node is being set to "-1".'].join(`
`)), p.current.setAttribute("tabIndex", "-1")), m.current && p.current.focus()), () => {
      i || (h.current && h.current.focus && (b.current = !0, h.current.focus()), h.current = null);
    };
  }, [a]), u.useEffect(() => {
    if (!a || !p.current)
      return;
    const l = A(p.current), g = (T) => {
      N.current = T, !(o || !c() || T.key !== "Tab") && l.activeElement === p.current && T.shiftKey && (b.current = !0, k.current && k.current.focus());
    }, v = () => {
      var P, M;
      const T = p.current;
      if (T === null)
        return;
      if (!l.hasFocus() || !c() || b.current) {
        b.current = !1;
        return;
      }
      if (T.contains(l.activeElement) || o && l.activeElement !== E.current && l.activeElement !== k.current)
        return;
      if (l.activeElement !== y.current)
        y.current = null;
      else if (y.current !== null)
        return;
      if (!m.current)
        return;
      let C = [];
      if ((l.activeElement === E.current || l.activeElement === k.current) && (C = r(p.current)), C.length > 0) {
        const D = !!((P = N.current) != null && P.shiftKey && ((M = N.current) == null ? void 0 : M.key) === "Tab"), B = C[0], U = C[C.length - 1];
        typeof B != "string" && typeof U != "string" && (D ? U.focus() : B.focus());
      } else
        T.focus();
    };
    l.addEventListener("focusin", v), l.addEventListener("keydown", g, !0);
    const F = setInterval(() => {
      l.activeElement && l.activeElement.tagName === "BODY" && v();
    }, 50);
    return () => {
      clearInterval(F), l.removeEventListener("focusin", v), l.removeEventListener("keydown", g, !0);
    };
  }, [s, o, i, c, a, r]);
  const S = (l) => {
    h.current === null && (h.current = l.relatedTarget), m.current = !0, y.current = l.target;
    const g = t.props.onFocus;
    g && g(l);
  }, R = (l) => {
    h.current === null && (h.current = l.relatedTarget), m.current = !0;
  };
  return /* @__PURE__ */ se(u.Fragment, {
    children: [/* @__PURE__ */ j("div", {
      tabIndex: a ? 0 : -1,
      onFocus: R,
      ref: E,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ u.cloneElement(t, {
      ref: w,
      onFocus: S
    }), /* @__PURE__ */ j("div", {
      tabIndex: a ? 0 : -1,
      onFocus: R,
      ref: k,
      "data-testid": "sentinelEnd"
    })]
  });
}
process.env.NODE_ENV !== "production" && (V.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * A single child content element.
   */
  children: ce,
  /**
   * If `true`, the focus trap will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any focus trap children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the focus trap less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableAutoFocus: n.bool,
  /**
   * If `true`, the focus trap will not prevent focus from leaving the focus trap while open.
   *
   * Generally this should never be set to `true` as it makes the focus trap less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableEnforceFocus: n.bool,
  /**
   * If `true`, the focus trap will not restore focus to previously focused element once
   * focus trap is hidden or unmounted.
   * @default false
   */
  disableRestoreFocus: n.bool,
  /**
   * Returns an array of ordered tabbable nodes (i.e. in tab order) within the root.
   * For instance, you can provide the "tabbable" npm dependency.
   * @param {HTMLElement} root
   */
  getTabbable: n.func,
  /**
   * This prop extends the `open` prop.
   * It allows to toggle the open state without having to wait for a rerender when changing the `open` prop.
   * This prop should be memoized.
   * It can be used to support multiple focus trap mounted at the same time.
   * @default function defaultIsEnabled(): boolean {
   *   return true;
   * }
   */
  isEnabled: n.func,
  /**
   * If `true`, focus is locked.
   */
  open: n.bool.isRequired
});
process.env.NODE_ENV !== "production" && (V.propTypes = xe(V.propTypes));
function je(e) {
  return typeof e == "function" ? e() : e;
}
function Ke(e) {
  return e ? e.props.hasOwnProperty("in") : !1;
}
const H = new Me();
function Ue(e) {
  const {
    container: t,
    disableEscapeKeyDown: s = !1,
    disableScrollLock: o = !1,
    closeAfterTransition: i = !1,
    onTransitionEnter: r,
    onTransitionExited: c,
    children: a,
    onClose: b,
    open: E,
    rootRef: k
  } = e, h = u.useRef({}), y = u.useRef(null), m = u.useRef(null), p = Y(m, k), [w, N] = u.useState(!E), S = Ke(a);
  let R = !0;
  (e["aria-hidden"] === "false" || e["aria-hidden"] === !1) && (R = !1);
  const l = () => A(y.current), g = () => (h.current.modalRef = m.current, h.current.mount = y.current, h.current), v = () => {
    H.mount(g(), {
      disableScrollLock: o
    }), m.current && (m.current.scrollTop = 0);
  }, F = ee(() => {
    const d = je(t) || l().body;
    H.add(g(), d), m.current && v();
  }), T = () => H.isTopModal(g()), C = ee((d) => {
    y.current = d, d && (E && T() ? v() : m.current && K(m.current, R));
  }), P = u.useCallback(() => {
    H.remove(g(), R);
  }, [R]);
  u.useEffect(() => () => {
    P();
  }, [P]), u.useEffect(() => {
    E ? F() : (!S || !i) && P();
  }, [E, P, S, i, F]);
  const M = (d) => (f) => {
    var x;
    (x = d.onKeyDown) == null || x.call(d, f), !(f.key !== "Escape" || f.which === 229 || // Wait until IME is settled.
    !T()) && (s || (f.stopPropagation(), b && b(f, "escapeKeyDown")));
  }, D = (d) => (f) => {
    var x;
    (x = d.onClick) == null || x.call(d, f), f.target === f.currentTarget && b && b(f, "backdropClick");
  };
  return {
    getRootProps: (d = {}) => {
      const f = Ee(e);
      delete f.onTransitionEnter, delete f.onTransitionExited;
      const x = {
        ...f,
        ...d
      };
      return {
        /*
         * Marking an element with the role presentation indicates to assistive technology
         * that this element should be ignored; it exists to support the web application and
         * is not meant for humans to interact with directly.
         * https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-static-element-interactions.md
         */
        role: "presentation",
        ...x,
        onKeyDown: M(x),
        ref: p
      };
    },
    getBackdropProps: (d = {}) => {
      const f = d;
      return {
        "aria-hidden": !0,
        ...f,
        onClick: D(f),
        open: E
      };
    },
    getTransitionProps: () => {
      const d = () => {
        N(!1), r && r();
      }, f = () => {
        N(!0), c && c(), i && P();
      };
      return {
        onEnter: te(d, a == null ? void 0 : a.props.onEnter),
        onExited: te(f, a == null ? void 0 : a.props.onExited)
      };
    },
    rootRef: p,
    portalRef: C,
    isTopModal: T,
    exited: w,
    hasTransition: S
  };
}
function We(e) {
  return he("MuiModal", e);
}
me("MuiModal", ["root", "hidden", "backdrop"]);
const qe = (e) => {
  const {
    open: t,
    exited: s,
    classes: o
  } = e;
  return ye({
    root: ["root", !t && s && "hidden"],
    backdrop: ["backdrop"]
  }, We, o);
}, He = ie("div", {
  name: "MuiModal",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: s
    } = e;
    return [t.root, !s.open && s.exited && t.hidden];
  }
})(ge(({
  theme: e
}) => ({
  position: "fixed",
  zIndex: (e.vars || e).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  variants: [{
    props: ({
      ownerState: t
    }) => !t.open && t.exited,
    style: {
      visibility: "hidden"
    }
  }]
}))), ze = ie(Re, {
  name: "MuiModal",
  slot: "Backdrop",
  overridesResolver: (e, t) => t.backdrop
})({
  zIndex: -1
}), Ve = /* @__PURE__ */ u.forwardRef(function(t, s) {
  const o = Te({
    name: "MuiModal",
    props: t
  }), {
    BackdropComponent: i = ze,
    BackdropProps: r,
    classes: c,
    className: a,
    closeAfterTransition: b = !1,
    children: E,
    container: k,
    component: h,
    components: y = {},
    componentsProps: m = {},
    disableAutoFocus: p = !1,
    disableEnforceFocus: w = !1,
    disableEscapeKeyDown: N = !1,
    disablePortal: S = !1,
    disableRestoreFocus: R = !1,
    disableScrollLock: l = !1,
    hideBackdrop: g = !1,
    keepMounted: v = !1,
    onBackdropClick: F,
    onClose: T,
    onTransitionEnter: C,
    onTransitionExited: P,
    open: M,
    slotProps: D = {},
    slots: B = {},
    // eslint-disable-next-line react/prop-types
    theme: U,
    ..._
  } = o, d = {
    ...o,
    closeAfterTransition: b,
    disableAutoFocus: p,
    disableEnforceFocus: w,
    disableEscapeKeyDown: N,
    disablePortal: S,
    disableRestoreFocus: R,
    disableScrollLock: l,
    hideBackdrop: g,
    keepMounted: v
  }, {
    getRootProps: f,
    getBackdropProps: x,
    getTransitionProps: ae,
    portalRef: le,
    isTopModal: ue,
    exited: G,
    hasTransition: X
  } = Ue({
    ...d,
    rootRef: s
  }), L = {
    ...d,
    exited: G
  }, I = qe(L), W = {};
  if (E.props.tabIndex === void 0 && (W.tabIndex = "-1"), X) {
    const {
      onEnter: O,
      onExited: q
    } = ae();
    W.onEnter = O, W.onExited = q;
  }
  const J = {
    ..._,
    slots: {
      root: y.Root,
      backdrop: y.Backdrop,
      ...B
    },
    slotProps: {
      ...m,
      ...D
    }
  }, [de, fe] = oe("root", {
    elementType: He,
    externalForwardedProps: J,
    getSlotProps: f,
    additionalProps: {
      ref: s,
      as: h
    },
    ownerState: L,
    className: Z(a, I == null ? void 0 : I.root, !L.open && L.exited && (I == null ? void 0 : I.hidden))
  }), [pe, Q] = oe("backdrop", {
    elementType: i,
    externalForwardedProps: J,
    additionalProps: r,
    getSlotProps: (O) => x({
      ...O,
      onClick: (q) => {
        F && F(q), O != null && O.onClick && O.onClick(q);
      }
    }),
    className: Z(r == null ? void 0 : r.className, I == null ? void 0 : I.backdrop),
    ownerState: L
  }), be = Y(r == null ? void 0 : r.ref, Q.ref);
  return !v && !M && (!X || G) ? null : /* @__PURE__ */ j(ke, {
    ref: le,
    container: k,
    disablePortal: S,
    children: /* @__PURE__ */ se(de, {
      ...fe,
      children: [!g && i ? /* @__PURE__ */ j(pe, {
        ...Q,
        ref: be
      }) : null, /* @__PURE__ */ j(V, {
        disableEnforceFocus: w,
        disableAutoFocus: p,
        disableRestoreFocus: R,
        isEnabled: ue,
        open: M,
        children: /* @__PURE__ */ u.cloneElement(E, W)
      })]
    })
  });
});
process.env.NODE_ENV !== "production" && (Ve.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * A backdrop component. This prop enables custom backdrop rendering.
   * @deprecated Use `slots.backdrop` instead. While this prop currently works, it will be removed in the next major version.
   * Use the `slots.backdrop` prop to make your application ready for the next version of Material UI.
   * @default styled(Backdrop, {
   *   name: 'MuiModal',
   *   slot: 'Backdrop',
   *   overridesResolver: (props, styles) => {
   *     return styles.backdrop;
   *   },
   * })({
   *   zIndex: -1,
   * })
   */
  BackdropComponent: n.elementType,
  /**
   * Props applied to the [`Backdrop`](https://mui.com/material-ui/api/backdrop/) element.
   * @deprecated Use `slotProps.backdrop` instead.
   */
  BackdropProps: n.object,
  /**
   * A single child content element.
   */
  children: ce.isRequired,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: n.object,
  /**
   * @ignore
   */
  className: n.string,
  /**
   * When set to true the Modal waits until a nested Transition is completed before closing.
   * @default false
   */
  closeAfterTransition: n.bool,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: n.elementType,
  /**
   * The components used for each slot inside.
   *
   * @deprecated Use the `slots` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  components: n.shape({
    Backdrop: n.elementType,
    Root: n.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @deprecated Use the `slotProps` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  componentsProps: n.shape({
    backdrop: n.oneOfType([n.func, n.object]),
    root: n.oneOfType([n.func, n.object])
  }),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: n.oneOfType([ve, n.func]),
  /**
   * If `true`, the modal will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any modal children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableAutoFocus: n.bool,
  /**
   * If `true`, the modal will not prevent focus from leaving the modal while open.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableEnforceFocus: n.bool,
  /**
   * If `true`, hitting escape will not fire the `onClose` callback.
   * @default false
   */
  disableEscapeKeyDown: n.bool,
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: n.bool,
  /**
   * If `true`, the modal will not restore focus to previously focused element once
   * modal is hidden or unmounted.
   * @default false
   */
  disableRestoreFocus: n.bool,
  /**
   * Disable the scroll lock behavior.
   * @default false
   */
  disableScrollLock: n.bool,
  /**
   * If `true`, the backdrop is not rendered.
   * @default false
   */
  hideBackdrop: n.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Modal.
   * @default false
   */
  keepMounted: n.bool,
  /**
   * Callback fired when the backdrop is clicked.
   * @deprecated Use the `onClose` prop with the `reason` argument to handle the `backdropClick` events.
   */
  onBackdropClick: n.func,
  /**
   * Callback fired when the component requests to be closed.
   * The `reason` parameter can optionally be used to control the response to `onClose`.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
   */
  onClose: n.func,
  /**
   * A function called when a transition enters.
   */
  onTransitionEnter: n.func,
  /**
   * A function called when a transition has exited.
   */
  onTransitionExited: n.func,
  /**
   * If `true`, the component is shown.
   */
  open: n.bool.isRequired,
  /**
   * The props used for each slot inside the Modal.
   * @default {}
   */
  slotProps: n.shape({
    backdrop: n.oneOfType([n.func, n.object]),
    root: n.oneOfType([n.func, n.object])
  }),
  /**
   * The components used for each slot inside the Modal.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: n.shape({
    backdrop: n.elementType,
    root: n.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: n.oneOfType([n.arrayOf(n.oneOfType([n.func, n.object, n.bool])), n.func, n.object])
});
export {
  V as F,
  Ve as M,
  Ie as g
};
