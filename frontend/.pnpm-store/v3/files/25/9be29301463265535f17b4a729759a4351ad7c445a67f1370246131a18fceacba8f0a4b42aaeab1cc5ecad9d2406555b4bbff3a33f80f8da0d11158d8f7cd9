import * as c from "react";
import { H as pt, I as ft, L as Wt, G as W, P as e } from "./identifier-B7MO0PvI.js";
import { m as bt } from "./memoTheme-CqfvfBST.js";
import { jsxs as q, jsx as x } from "react/jsx-runtime";
import { s as L, u as ht, c as mt, e as ee } from "./DefaultPropsProvider-BYFwNPLt.js";
import { B as kt } from "./ButtonBase-z74SMnd9.js";
import { a as oe } from "./useThemeProps-B9UyPpzT.js";
import { u as zt, a as rt } from "./index-yb8koCDz.js";
import { u as re } from "./useTheme-CzzAEESs.js";
import { u as ne, r as le } from "./refType-BqQbA6de.js";
import { o as Dt } from "./ownerWindow-niciwP7I.js";
import { d as $t } from "./debounce-46wSf_lW.js";
import { a as dt } from "./useTimeout-Znm_nF2D.js";
import { c as At } from "./createSvgIcon-BS0Qe85N.js";
import { o as se } from "./ownerDocument-CUrv0DIK.js";
function ae(o) {
  return pt("MuiTab", o);
}
const T = ft("MuiTab", ["root", "labelIcon", "textColorInherit", "textColorPrimary", "textColorSecondary", "selected", "disabled", "fullWidth", "wrapped", "iconWrapper", "icon"]), ie = (o) => {
  const {
    classes: t,
    textColor: l,
    fullWidth: d,
    wrapped: i,
    icon: u,
    label: b,
    selected: h,
    disabled: f
  } = o, S = {
    root: ["root", u && b && "labelIcon", `textColor${Wt(l)}`, d && "fullWidth", i && "wrapped", h && "selected", f && "disabled"],
    icon: ["iconWrapper", "icon"]
  };
  return mt(S, ae, t);
}, ce = L(kt, {
  name: "MuiTab",
  slot: "Root",
  overridesResolver: (o, t) => {
    const {
      ownerState: l
    } = o;
    return [t.root, l.label && l.icon && t.labelIcon, t[`textColor${Wt(l.textColor)}`], l.fullWidth && t.fullWidth, l.wrapped && t.wrapped, {
      [`& .${T.iconWrapper}`]: t.iconWrapper
    }, {
      [`& .${T.icon}`]: t.icon
    }];
  }
})(bt(({
  theme: o
}) => ({
  ...o.typography.button,
  maxWidth: 360,
  minWidth: 90,
  position: "relative",
  minHeight: 48,
  flexShrink: 0,
  padding: "12px 16px",
  overflow: "hidden",
  whiteSpace: "normal",
  textAlign: "center",
  lineHeight: 1.25,
  variants: [{
    props: ({
      ownerState: t
    }) => t.label && (t.iconPosition === "top" || t.iconPosition === "bottom"),
    style: {
      flexDirection: "column"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.label && t.iconPosition !== "top" && t.iconPosition !== "bottom",
    style: {
      flexDirection: "row"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.icon && t.label,
    style: {
      minHeight: 72,
      paddingTop: 9,
      paddingBottom: 9
    }
  }, {
    props: ({
      ownerState: t,
      iconPosition: l
    }) => t.icon && t.label && l === "top",
    style: {
      [`& > .${T.icon}`]: {
        marginBottom: 6
      }
    }
  }, {
    props: ({
      ownerState: t,
      iconPosition: l
    }) => t.icon && t.label && l === "bottom",
    style: {
      [`& > .${T.icon}`]: {
        marginTop: 6
      }
    }
  }, {
    props: ({
      ownerState: t,
      iconPosition: l
    }) => t.icon && t.label && l === "start",
    style: {
      [`& > .${T.icon}`]: {
        marginRight: o.spacing(1)
      }
    }
  }, {
    props: ({
      ownerState: t,
      iconPosition: l
    }) => t.icon && t.label && l === "end",
    style: {
      [`& > .${T.icon}`]: {
        marginLeft: o.spacing(1)
      }
    }
  }, {
    props: {
      textColor: "inherit"
    },
    style: {
      color: "inherit",
      opacity: 0.6,
      // same opacity as theme.palette.text.secondary
      [`&.${T.selected}`]: {
        opacity: 1
      },
      [`&.${T.disabled}`]: {
        opacity: (o.vars || o).palette.action.disabledOpacity
      }
    }
  }, {
    props: {
      textColor: "primary"
    },
    style: {
      color: (o.vars || o).palette.text.secondary,
      [`&.${T.selected}`]: {
        color: (o.vars || o).palette.primary.main
      },
      [`&.${T.disabled}`]: {
        color: (o.vars || o).palette.text.disabled
      }
    }
  }, {
    props: {
      textColor: "secondary"
    },
    style: {
      color: (o.vars || o).palette.text.secondary,
      [`&.${T.selected}`]: {
        color: (o.vars || o).palette.secondary.main
      },
      [`&.${T.disabled}`]: {
        color: (o.vars || o).palette.text.disabled
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.fullWidth,
    style: {
      flexShrink: 1,
      flexGrow: 1,
      flexBasis: 0,
      maxWidth: "none"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.wrapped,
    style: {
      fontSize: o.typography.pxToRem(12)
    }
  }]
}))), de = /* @__PURE__ */ c.forwardRef(function(t, l) {
  const d = ht({
    props: t,
    name: "MuiTab"
  }), {
    className: i,
    disabled: u = !1,
    disableFocusRipple: b = !1,
    // eslint-disable-next-line react/prop-types
    fullWidth: h,
    icon: f,
    iconPosition: S = "top",
    // eslint-disable-next-line react/prop-types
    indicator: v,
    label: y,
    onChange: m,
    onClick: C,
    onFocus: k,
    // eslint-disable-next-line react/prop-types
    selected: I,
    // eslint-disable-next-line react/prop-types
    selectionFollowsFocus: g,
    // eslint-disable-next-line react/prop-types
    textColor: j = "inherit",
    value: M,
    wrapped: nt = !1,
    ...H
  } = d, U = {
    ...d,
    disabled: u,
    disableFocusRipple: b,
    selected: I,
    icon: !!f,
    iconPosition: S,
    label: !!y,
    fullWidth: h,
    textColor: j,
    wrapped: nt
  }, V = ie(U), z = f && y && /* @__PURE__ */ c.isValidElement(f) ? /* @__PURE__ */ c.cloneElement(f, {
    className: W(V.icon, f.props.className)
  }) : f, G = (R) => {
    !I && m && m(R, M), C && C(R);
  }, N = (R) => {
    g && !I && m && m(R, M), k && k(R);
  };
  return /* @__PURE__ */ q(ce, {
    focusRipple: !b,
    className: W(V.root, i),
    ref: l,
    role: "tab",
    "aria-selected": I,
    disabled: u,
    onClick: G,
    onFocus: N,
    ownerState: U,
    tabIndex: I ? 0 : -1,
    ...H,
    children: [S === "top" || S === "start" ? /* @__PURE__ */ q(c.Fragment, {
      children: [z, y]
    }) : /* @__PURE__ */ q(c.Fragment, {
      children: [y, z]
    }), v]
  });
});
process.env.NODE_ENV !== "production" && (de.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * This prop isn't supported.
   * Use the `component` prop if you need to change the children structure.
   */
  children: oe,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: e.object,
  /**
   * @ignore
   */
  className: e.string,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: e.bool,
  /**
   * If `true`, the  keyboard focus ripple is disabled.
   * @default false
   */
  disableFocusRipple: e.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   * ⚠️ Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: e.bool,
  /**
   * The icon to display.
   */
  icon: e.oneOfType([e.element, e.string]),
  /**
   * The position of the icon relative to the label.
   * @default 'top'
   */
  iconPosition: e.oneOf(["bottom", "end", "start", "top"]),
  /**
   * The label element.
   */
  label: e.node,
  /**
   * @ignore
   */
  onChange: e.func,
  /**
   * @ignore
   */
  onClick: e.func,
  /**
   * @ignore
   */
  onFocus: e.func,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: e.oneOfType([e.arrayOf(e.oneOfType([e.func, e.object, e.bool])), e.func, e.object]),
  /**
   * You can provide your own value. Otherwise, we fallback to the child position index.
   */
  value: e.any,
  /**
   * Tab labels appear in a single row.
   * They can use a second line if needed.
   * @default false
   */
  wrapped: e.bool
});
const ue = At(/* @__PURE__ */ x("path", {
  d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"
}), "KeyboardArrowLeft"), pe = At(/* @__PURE__ */ x("path", {
  d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"
}), "KeyboardArrowRight");
function fe(o) {
  return (1 + Math.sin(Math.PI * o - Math.PI / 2)) / 2;
}
function be(o, t, l, d = {}, i = () => {
}) {
  const {
    ease: u = fe,
    duration: b = 300
    // standard
  } = d;
  let h = null;
  const f = t[o];
  let S = !1;
  const v = () => {
    S = !0;
  }, y = (m) => {
    if (S) {
      i(new Error("Animation cancelled"));
      return;
    }
    h === null && (h = m);
    const C = Math.min(1, (m - h) / b);
    if (t[o] = u(C) * (l - f) + f, C >= 1) {
      requestAnimationFrame(() => {
        i(null);
      });
      return;
    }
    requestAnimationFrame(y);
  };
  return f === l ? (i(new Error("Element already at target position")), v) : (requestAnimationFrame(y), v);
}
const he = {
  width: 99,
  height: 99,
  position: "absolute",
  top: -9999,
  overflow: "scroll"
};
function Ft(o) {
  const {
    onChange: t,
    ...l
  } = o, d = c.useRef(), i = c.useRef(null), u = () => {
    d.current = i.current.offsetHeight - i.current.clientHeight;
  };
  return ne(() => {
    const b = $t(() => {
      const f = d.current;
      u(), f !== d.current && t(d.current);
    }), h = Dt(i.current);
    return h.addEventListener("resize", b), () => {
      b.clear(), h.removeEventListener("resize", b);
    };
  }, [t]), c.useEffect(() => {
    u(), t(d.current);
  }, [t]), /* @__PURE__ */ x("div", {
    style: he,
    ref: i,
    ...l
  });
}
process.env.NODE_ENV !== "production" && (Ft.propTypes = {
  onChange: e.func.isRequired
});
function me(o) {
  return pt("MuiTabScrollButton", o);
}
const Se = ft("MuiTabScrollButton", ["root", "vertical", "horizontal", "disabled"]), ve = (o) => {
  const {
    classes: t,
    orientation: l,
    disabled: d
  } = o;
  return mt({
    root: ["root", l, d && "disabled"]
  }, me, t);
}, ye = L(kt, {
  name: "MuiTabScrollButton",
  slot: "Root",
  overridesResolver: (o, t) => {
    const {
      ownerState: l
    } = o;
    return [t.root, l.orientation && t[l.orientation]];
  }
})({
  width: 40,
  flexShrink: 0,
  opacity: 0.8,
  [`&.${Se.disabled}`]: {
    opacity: 0
  },
  variants: [{
    props: {
      orientation: "vertical"
    },
    style: {
      width: "100%",
      height: 40,
      "& svg": {
        transform: "var(--TabScrollButton-svgRotate)"
      }
    }
  }]
}), Lt = /* @__PURE__ */ c.forwardRef(function(t, l) {
  const d = ht({
    props: t,
    name: "MuiTabScrollButton"
  }), {
    className: i,
    slots: u = {},
    slotProps: b = {},
    direction: h,
    orientation: f,
    disabled: S,
    ...v
  } = d, y = zt(), m = {
    isRtl: y,
    ...d
  }, C = ve(m), k = u.StartScrollButtonIcon ?? ue, I = u.EndScrollButtonIcon ?? pe, g = rt({
    elementType: k,
    externalSlotProps: b.startScrollButtonIcon,
    additionalProps: {
      fontSize: "small"
    },
    ownerState: m
  }), j = rt({
    elementType: I,
    externalSlotProps: b.endScrollButtonIcon,
    additionalProps: {
      fontSize: "small"
    },
    ownerState: m
  });
  return /* @__PURE__ */ x(ye, {
    component: "div",
    className: W(C.root, i),
    ref: l,
    role: null,
    ownerState: m,
    tabIndex: null,
    ...v,
    style: {
      ...v.style,
      ...f === "vertical" && {
        "--TabScrollButton-svgRotate": `rotate(${y ? -90 : 90}deg)`
      }
    },
    children: h === "left" ? /* @__PURE__ */ x(k, {
      ...g
    }) : /* @__PURE__ */ x(I, {
      ...j
    })
  });
});
process.env.NODE_ENV !== "production" && (Lt.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * The content of the component.
   */
  children: e.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: e.object,
  /**
   * @ignore
   */
  className: e.string,
  /**
   * The direction the button should indicate.
   */
  direction: e.oneOf(["left", "right"]).isRequired,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: e.bool,
  /**
   * The component orientation (layout flow direction).
   */
  orientation: e.oneOf(["horizontal", "vertical"]).isRequired,
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   * @default {}
   */
  slotProps: e.shape({
    endScrollButtonIcon: e.oneOfType([e.func, e.object]),
    startScrollButtonIcon: e.oneOfType([e.func, e.object])
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: e.shape({
    EndScrollButtonIcon: e.elementType,
    StartScrollButtonIcon: e.elementType
  }),
  /**
   * @ignore
   */
  style: e.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: e.oneOfType([e.arrayOf(e.oneOfType([e.func, e.object, e.bool])), e.func, e.object])
});
function ge(o) {
  return pt("MuiTabs", o);
}
const ut = ft("MuiTabs", ["root", "vertical", "flexContainer", "flexContainerVertical", "centered", "scroller", "fixed", "scrollableX", "scrollableY", "hideScrollbar", "scrollButtons", "scrollButtonsHideMobile", "indicator"]), Rt = (o, t) => o === t ? o.firstChild : t && t.nextElementSibling ? t.nextElementSibling : o.firstChild, Ot = (o, t) => o === t ? o.lastChild : t && t.previousElementSibling ? t.previousElementSibling : o.lastChild, ot = (o, t, l) => {
  let d = !1, i = l(o, t);
  for (; i; ) {
    if (i === o.firstChild) {
      if (d)
        return;
      d = !0;
    }
    const u = i.disabled || i.getAttribute("aria-disabled") === "true";
    if (!i.hasAttribute("tabindex") || u)
      i = l(o, i);
    else {
      i.focus();
      return;
    }
  }
}, Te = (o) => {
  const {
    vertical: t,
    fixed: l,
    hideScrollbar: d,
    scrollableX: i,
    scrollableY: u,
    centered: b,
    scrollButtonsHideMobile: h,
    classes: f
  } = o;
  return mt({
    root: ["root", t && "vertical"],
    scroller: ["scroller", l && "fixed", d && "hideScrollbar", i && "scrollableX", u && "scrollableY"],
    flexContainer: ["flexContainer", t && "flexContainerVertical", b && "centered"],
    indicator: ["indicator"],
    scrollButtons: ["scrollButtons", h && "scrollButtonsHideMobile"],
    scrollableX: [i && "scrollableX"],
    hideScrollbar: [d && "hideScrollbar"]
  }, ge, f);
}, we = L("div", {
  name: "MuiTabs",
  slot: "Root",
  overridesResolver: (o, t) => {
    const {
      ownerState: l
    } = o;
    return [{
      [`& .${ut.scrollButtons}`]: t.scrollButtons
    }, {
      [`& .${ut.scrollButtons}`]: l.scrollButtonsHideMobile && t.scrollButtonsHideMobile
    }, t.root, l.vertical && t.vertical];
  }
})(bt(({
  theme: o
}) => ({
  overflow: "hidden",
  minHeight: 48,
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch",
  display: "flex",
  variants: [{
    props: ({
      ownerState: t
    }) => t.vertical,
    style: {
      flexDirection: "column"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.scrollButtonsHideMobile,
    style: {
      [`& .${ut.scrollButtons}`]: {
        [o.breakpoints.down("sm")]: {
          display: "none"
        }
      }
    }
  }]
}))), Be = L("div", {
  name: "MuiTabs",
  slot: "Scroller",
  overridesResolver: (o, t) => {
    const {
      ownerState: l
    } = o;
    return [t.scroller, l.fixed && t.fixed, l.hideScrollbar && t.hideScrollbar, l.scrollableX && t.scrollableX, l.scrollableY && t.scrollableY];
  }
})({
  position: "relative",
  display: "inline-block",
  flex: "1 1 auto",
  whiteSpace: "nowrap",
  variants: [{
    props: ({
      ownerState: o
    }) => o.fixed,
    style: {
      overflowX: "hidden",
      width: "100%"
    }
  }, {
    props: ({
      ownerState: o
    }) => o.hideScrollbar,
    style: {
      // Hide dimensionless scrollbar on macOS
      scrollbarWidth: "none",
      // Firefox
      "&::-webkit-scrollbar": {
        display: "none"
        // Safari + Chrome
      }
    }
  }, {
    props: ({
      ownerState: o
    }) => o.scrollableX,
    style: {
      overflowX: "auto",
      overflowY: "hidden"
    }
  }, {
    props: ({
      ownerState: o
    }) => o.scrollableY,
    style: {
      overflowY: "auto",
      overflowX: "hidden"
    }
  }]
}), xe = L("div", {
  name: "MuiTabs",
  slot: "FlexContainer",
  overridesResolver: (o, t) => {
    const {
      ownerState: l
    } = o;
    return [t.flexContainer, l.vertical && t.flexContainerVertical, l.centered && t.centered];
  }
})({
  display: "flex",
  variants: [{
    props: ({
      ownerState: o
    }) => o.vertical,
    style: {
      flexDirection: "column"
    }
  }, {
    props: ({
      ownerState: o
    }) => o.centered,
    style: {
      justifyContent: "center"
    }
  }]
}), Ce = L("span", {
  name: "MuiTabs",
  slot: "Indicator",
  overridesResolver: (o, t) => t.indicator
})(bt(({
  theme: o
}) => ({
  position: "absolute",
  height: 2,
  bottom: 0,
  width: "100%",
  transition: o.transitions.create(),
  variants: [{
    props: {
      indicatorColor: "primary"
    },
    style: {
      backgroundColor: (o.vars || o).palette.primary.main
    }
  }, {
    props: {
      indicatorColor: "secondary"
    },
    style: {
      backgroundColor: (o.vars || o).palette.secondary.main
    }
  }, {
    props: ({
      ownerState: t
    }) => t.vertical,
    style: {
      height: "100%",
      width: 2,
      right: 0
    }
  }]
}))), Ie = L(Ft)({
  overflowX: "auto",
  overflowY: "hidden",
  // Hide dimensionless scrollbar on macOS
  scrollbarWidth: "none",
  // Firefox
  "&::-webkit-scrollbar": {
    display: "none"
    // Safari + Chrome
  }
}), Nt = {};
let Pt = !1;
const Ee = /* @__PURE__ */ c.forwardRef(function(t, l) {
  const d = ht({
    props: t,
    name: "MuiTabs"
  }), i = re(), u = zt(), {
    "aria-label": b,
    "aria-labelledby": h,
    action: f,
    centered: S = !1,
    children: v,
    className: y,
    component: m = "div",
    allowScrollButtonsMobile: C = !1,
    indicatorColor: k = "primary",
    onChange: I,
    orientation: g = "horizontal",
    ScrollButtonComponent: j = Lt,
    scrollButtons: M = "auto",
    selectionFollowsFocus: nt,
    slots: H = {},
    slotProps: U = {},
    TabIndicatorProps: V = {},
    TabScrollButtonProps: z = {},
    textColor: G = "primary",
    value: N,
    variant: R = "standard",
    visibleScrollbar: lt = !1,
    ...jt
  } = d, w = R === "scrollable", B = g === "vertical", X = B ? "scrollTop" : "scrollLeft", J = B ? "top" : "left", Q = B ? "bottom" : "right", st = B ? "clientHeight" : "clientWidth", Y = B ? "height" : "width", D = {
    ...d,
    component: m,
    allowScrollButtonsMobile: C,
    indicatorColor: k,
    orientation: g,
    vertical: B,
    scrollButtons: M,
    textColor: G,
    variant: R,
    visibleScrollbar: lt,
    fixed: !w,
    hideScrollbar: w && !lt,
    scrollableX: w && !B,
    scrollableY: w && B,
    centered: S && !w,
    scrollButtonsHideMobile: !C
  }, P = Te(D), Ht = rt({
    elementType: H.StartScrollButtonIcon,
    externalSlotProps: U.startScrollButtonIcon,
    ownerState: D
  }), Vt = rt({
    elementType: H.EndScrollButtonIcon,
    externalSlotProps: U.endScrollButtonIcon,
    ownerState: D
  });
  process.env.NODE_ENV !== "production" && S && w && console.error('MUI: You can not use the `centered={true}` and `variant="scrollable"` properties at the same time on a `Tabs` component.');
  const [St, Ut] = c.useState(!1), [$, vt] = c.useState(Nt), [yt, Xt] = c.useState(!1), [gt, Yt] = c.useState(!1), [Tt, Kt] = c.useState(!1), [wt, _t] = c.useState({
    overflow: "hidden",
    scrollbarWidth: 0
  }), Z = /* @__PURE__ */ new Map(), O = c.useRef(null), A = c.useRef(null), Bt = () => {
    const r = O.current;
    let n;
    if (r) {
      const a = r.getBoundingClientRect();
      n = {
        clientWidth: r.clientWidth,
        scrollLeft: r.scrollLeft,
        scrollTop: r.scrollTop,
        scrollWidth: r.scrollWidth,
        top: a.top,
        bottom: a.bottom,
        left: a.left,
        right: a.right
      };
    }
    let s;
    if (r && N !== !1) {
      const a = A.current.children;
      if (a.length > 0) {
        const p = a[Z.get(N)];
        process.env.NODE_ENV !== "production" && (p || console.error(["MUI: The `value` provided to the Tabs component is invalid.", `None of the Tabs' children match with "${N}".`, Z.keys ? `You can provide one of the following values: ${Array.from(Z.keys()).join(", ")}.` : null].join(`
`))), s = p ? p.getBoundingClientRect() : null, process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "test" && !Pt && s && s.width === 0 && s.height === 0 && // if the whole Tabs component is hidden, don't warn
        n.clientWidth !== 0 && (n = null, console.error(["MUI: The `value` provided to the Tabs component is invalid.", `The Tab with this \`value\` ("${N}") is not part of the document layout.`, "Make sure the tab item is present in the document or that it's not `display: none`."].join(`
`)), Pt = !0);
      }
    }
    return {
      tabsMeta: n,
      tabMeta: s
    };
  }, K = dt(() => {
    const {
      tabsMeta: r,
      tabMeta: n
    } = Bt();
    let s = 0, a;
    B ? (a = "top", n && r && (s = n.top - r.top + r.scrollTop)) : (a = u ? "right" : "left", n && r && (s = (u ? -1 : 1) * (n[a] - r[a] + r.scrollLeft)));
    const p = {
      [a]: s,
      // May be wrong until the font is loaded.
      [Y]: n ? n[Y] : 0
    };
    if (typeof $[a] != "number" || typeof $[Y] != "number")
      vt(p);
    else {
      const E = Math.abs($[a] - p[a]), F = Math.abs($[Y] - p[Y]);
      (E >= 1 || F >= 1) && vt(p);
    }
  }), at = (r, {
    animation: n = !0
  } = {}) => {
    n ? be(X, O.current, r, {
      duration: i.transitions.duration.standard
    }) : O.current[X] = r;
  }, xt = (r) => {
    let n = O.current[X];
    B ? n += r : n += r * (u ? -1 : 1), at(n);
  }, Ct = () => {
    const r = O.current[st];
    let n = 0;
    const s = Array.from(A.current.children);
    for (let a = 0; a < s.length; a += 1) {
      const p = s[a];
      if (n + p[st] > r) {
        a === 0 && (n = r);
        break;
      }
      n += p[st];
    }
    return n;
  }, qt = () => {
    xt(-1 * Ct());
  }, Gt = () => {
    xt(Ct());
  }, Jt = c.useCallback((r) => {
    _t({
      overflow: null,
      scrollbarWidth: r
    });
  }, []), Qt = () => {
    const r = {};
    r.scrollbarSizeListener = w ? /* @__PURE__ */ x(Ie, {
      onChange: Jt,
      className: W(P.scrollableX, P.hideScrollbar)
    }) : null;
    const s = w && (M === "auto" && (yt || gt) || M === !0);
    return r.scrollButtonStart = s ? /* @__PURE__ */ x(j, {
      slots: {
        StartScrollButtonIcon: H.StartScrollButtonIcon
      },
      slotProps: {
        startScrollButtonIcon: Ht
      },
      orientation: g,
      direction: u ? "right" : "left",
      onClick: qt,
      disabled: !yt,
      ...z,
      className: W(P.scrollButtons, z.className)
    }) : null, r.scrollButtonEnd = s ? /* @__PURE__ */ x(j, {
      slots: {
        EndScrollButtonIcon: H.EndScrollButtonIcon
      },
      slotProps: {
        endScrollButtonIcon: Vt
      },
      orientation: g,
      direction: u ? "left" : "right",
      onClick: Gt,
      disabled: !gt,
      ...z,
      className: W(P.scrollButtons, z.className)
    }) : null, r;
  }, It = dt((r) => {
    const {
      tabsMeta: n,
      tabMeta: s
    } = Bt();
    if (!(!s || !n)) {
      if (s[J] < n[J]) {
        const a = n[X] + (s[J] - n[J]);
        at(a, {
          animation: r
        });
      } else if (s[Q] > n[Q]) {
        const a = n[X] + (s[Q] - n[Q]);
        at(a, {
          animation: r
        });
      }
    }
  }), tt = dt(() => {
    w && M !== !1 && Kt(!Tt);
  });
  c.useEffect(() => {
    const r = $t(() => {
      O.current && K();
    });
    let n;
    const s = (E) => {
      E.forEach((F) => {
        F.removedNodes.forEach((_) => {
          n == null || n.unobserve(_);
        }), F.addedNodes.forEach((_) => {
          n == null || n.observe(_);
        });
      }), r(), tt();
    }, a = Dt(O.current);
    a.addEventListener("resize", r);
    let p;
    return typeof ResizeObserver < "u" && (n = new ResizeObserver(r), Array.from(A.current.children).forEach((E) => {
      n.observe(E);
    })), typeof MutationObserver < "u" && (p = new MutationObserver(s), p.observe(A.current, {
      childList: !0
    })), () => {
      r.clear(), a.removeEventListener("resize", r), p == null || p.disconnect(), n == null || n.disconnect();
    };
  }, [K, tt]), c.useEffect(() => {
    const r = Array.from(A.current.children), n = r.length;
    if (typeof IntersectionObserver < "u" && n > 0 && w && M !== !1) {
      const s = r[0], a = r[n - 1], p = {
        root: O.current,
        threshold: 0.99
      }, E = (ct) => {
        Xt(!ct[0].isIntersecting);
      }, F = new IntersectionObserver(E, p);
      F.observe(s);
      const _ = (ct) => {
        Yt(!ct[0].isIntersecting);
      }, Mt = new IntersectionObserver(_, p);
      return Mt.observe(a), () => {
        F.disconnect(), Mt.disconnect();
      };
    }
  }, [w, M, Tt, v == null ? void 0 : v.length]), c.useEffect(() => {
    Ut(!0);
  }, []), c.useEffect(() => {
    K();
  }), c.useEffect(() => {
    It(Nt !== $);
  }, [It, $]), c.useImperativeHandle(f, () => ({
    updateIndicator: K,
    updateScrollButtons: tt
  }), [K, tt]);
  const Et = /* @__PURE__ */ x(Ce, {
    ...V,
    className: W(P.indicator, V.className),
    ownerState: D,
    style: {
      ...$,
      ...V.style
    }
  });
  let et = 0;
  const Zt = c.Children.map(v, (r) => {
    if (!/* @__PURE__ */ c.isValidElement(r))
      return null;
    process.env.NODE_ENV !== "production" && ee.isFragment(r) && console.error(["MUI: The Tabs component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`));
    const n = r.props.value === void 0 ? et : r.props.value;
    Z.set(n, et);
    const s = n === N;
    return et += 1, /* @__PURE__ */ c.cloneElement(r, {
      fullWidth: R === "fullWidth",
      indicator: s && !St && Et,
      selected: s,
      selectionFollowsFocus: nt,
      onChange: I,
      textColor: G,
      value: n,
      ...et === 1 && N === !1 && !r.props.tabIndex ? {
        tabIndex: 0
      } : {}
    });
  }), te = (r) => {
    const n = A.current, s = se(n).activeElement;
    if (s.getAttribute("role") !== "tab")
      return;
    let p = g === "horizontal" ? "ArrowLeft" : "ArrowUp", E = g === "horizontal" ? "ArrowRight" : "ArrowDown";
    switch (g === "horizontal" && u && (p = "ArrowRight", E = "ArrowLeft"), r.key) {
      case p:
        r.preventDefault(), ot(n, s, Ot);
        break;
      case E:
        r.preventDefault(), ot(n, s, Rt);
        break;
      case "Home":
        r.preventDefault(), ot(n, null, Rt);
        break;
      case "End":
        r.preventDefault(), ot(n, null, Ot);
        break;
    }
  }, it = Qt();
  return /* @__PURE__ */ q(we, {
    className: W(P.root, y),
    ownerState: D,
    ref: l,
    as: m,
    ...jt,
    children: [it.scrollButtonStart, it.scrollbarSizeListener, /* @__PURE__ */ q(Be, {
      className: P.scroller,
      ownerState: D,
      style: {
        overflow: wt.overflow,
        [B ? `margin${u ? "Left" : "Right"}` : "marginBottom"]: lt ? void 0 : -wt.scrollbarWidth
      },
      ref: O,
      children: [/* @__PURE__ */ x(xe, {
        "aria-label": b,
        "aria-labelledby": h,
        "aria-orientation": g === "vertical" ? "vertical" : null,
        className: P.flexContainer,
        ownerState: D,
        onKeyDown: te,
        ref: A,
        role: "tablist",
        children: Zt
      }), St && Et]
    }), it.scrollButtonEnd]
  });
});
process.env.NODE_ENV !== "production" && (Ee.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * Callback fired when the component mounts.
   * This is useful when you want to trigger an action programmatically.
   * It supports two actions: `updateIndicator()` and `updateScrollButtons()`
   *
   * @param {object} actions This object contains all possible actions
   * that can be triggered programmatically.
   */
  action: le,
  /**
   * If `true`, the scroll buttons aren't forced hidden on mobile.
   * By default the scroll buttons are hidden on mobile and takes precedence over `scrollButtons`.
   * @default false
   */
  allowScrollButtonsMobile: e.bool,
  /**
   * The label for the Tabs as a string.
   */
  "aria-label": e.string,
  /**
   * An id or list of ids separated by a space that label the Tabs.
   */
  "aria-labelledby": e.string,
  /**
   * If `true`, the tabs are centered.
   * This prop is intended for large views.
   * @default false
   */
  centered: e.bool,
  /**
   * The content of the component.
   */
  children: e.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: e.object,
  /**
   * @ignore
   */
  className: e.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: e.elementType,
  /**
   * Determines the color of the indicator.
   * @default 'primary'
   */
  indicatorColor: e.oneOfType([e.oneOf(["primary", "secondary"]), e.string]),
  /**
   * Callback fired when the value changes.
   *
   * @param {React.SyntheticEvent} event The event source of the callback. **Warning**: This is a generic event not a change event.
   * @param {any} value We default to the index of the child (number)
   */
  onChange: e.func,
  /**
   * The component orientation (layout flow direction).
   * @default 'horizontal'
   */
  orientation: e.oneOf(["horizontal", "vertical"]),
  /**
   * The component used to render the scroll buttons.
   * @default TabScrollButton
   */
  ScrollButtonComponent: e.elementType,
  /**
   * Determine behavior of scroll buttons when tabs are set to scroll:
   *
   * - `auto` will only present them when not all the items are visible.
   * - `true` will always present them.
   * - `false` will never present them.
   *
   * By default the scroll buttons are hidden on mobile.
   * This behavior can be disabled with `allowScrollButtonsMobile`.
   * @default 'auto'
   */
  scrollButtons: e.oneOf(["auto", !1, !0]),
  /**
   * If `true` the selected tab changes on focus. Otherwise it only
   * changes on activation.
   */
  selectionFollowsFocus: e.bool,
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   * @default {}
   */
  slotProps: e.shape({
    endScrollButtonIcon: e.oneOfType([e.func, e.object]),
    startScrollButtonIcon: e.oneOfType([e.func, e.object])
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: e.shape({
    EndScrollButtonIcon: e.elementType,
    StartScrollButtonIcon: e.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: e.oneOfType([e.arrayOf(e.oneOfType([e.func, e.object, e.bool])), e.func, e.object]),
  /**
   * Props applied to the tab indicator element.
   * @default  {}
   */
  TabIndicatorProps: e.object,
  /**
   * Props applied to the [`TabScrollButton`](https://mui.com/material-ui/api/tab-scroll-button/) element.
   * @default {}
   */
  TabScrollButtonProps: e.object,
  /**
   * Determines the color of the `Tab`.
   * @default 'primary'
   */
  textColor: e.oneOf(["inherit", "primary", "secondary"]),
  /**
   * The value of the currently selected `Tab`.
   * If you don't want any selected `Tab`, you can set this prop to `false`.
   */
  value: e.any,
  /**
   * Determines additional display behavior of the tabs:
   *
   *  - `scrollable` will invoke scrolling properties and allow for horizontally
   *  scrolling (or swiping) of the tab bar.
   *  - `fullWidth` will make the tabs grow to use all the available space,
   *  which should be used for small views, like on mobile.
   *  - `standard` will render the default state.
   * @default 'standard'
   */
  variant: e.oneOf(["fullWidth", "scrollable", "standard"]),
  /**
   * If `true`, the scrollbar is visible. It can be useful when displaying
   * a long vertical list of tabs.
   * @default false
   */
  visibleScrollbar: e.bool
});
export {
  pe as K,
  de as T,
  Ee as a,
  ut as b,
  ge as c,
  ue as d,
  ae as g,
  T as t
};
