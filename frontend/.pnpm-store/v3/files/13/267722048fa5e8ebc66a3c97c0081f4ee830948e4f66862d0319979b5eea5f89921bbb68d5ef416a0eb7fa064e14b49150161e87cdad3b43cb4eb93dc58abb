import * as l from "react";
import { P as e, I as U, H as D, L as d, n as R, G } from "./identifier-B7MO0PvI.js";
import { S as V } from "./SwitchBase-DBnju71w.js";
import { c as z } from "./createSvgIcon-BS0Qe85N.js";
import { jsx as r, jsxs as _ } from "react/jsx-runtime";
import { s as p, r as O, u as q, c as H } from "./DefaultPropsProvider-BYFwNPLt.js";
import { m as I } from "./memoTheme-CqfvfBST.js";
import { u as L } from "./useFormControl-CatNKXAi.js";
import { c as g } from "./createSimplePaletteValueFilter-B7--0ryQ.js";
import { r as Z } from "./refType-BqQbA6de.js";
import { c as A } from "./createChainedFunction-C0nujS3O.js";
const J = z(/* @__PURE__ */ r("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
}), "RadioButtonUnchecked"), K = z(/* @__PURE__ */ r("path", {
  d: "M8.465 8.465C9.37 7.56 10.62 7 12 7C14.76 7 17 9.24 17 12C17 13.38 16.44 14.63 15.535 15.535C14.63 16.44 13.38 17 12 17C9.24 17 7 14.76 7 12C7 10.62 7.56 9.37 8.465 8.465Z"
}), "RadioButtonChecked"), Q = p("span", {
  shouldForwardProp: O
})({
  position: "relative",
  display: "flex"
}), W = p(J)({
  // Scale applied to prevent dot misalignment in Safari
  transform: "scale(1)"
}), X = p(K)(I(({
  theme: o
}) => ({
  left: 0,
  position: "absolute",
  transform: "scale(0)",
  transition: o.transitions.create("transform", {
    easing: o.transitions.easing.easeIn,
    duration: o.transitions.duration.shortest
  }),
  variants: [{
    props: {
      checked: !0
    },
    style: {
      transform: "scale(1)",
      transition: o.transitions.create("transform", {
        easing: o.transitions.easing.easeOut,
        duration: o.transitions.duration.shortest
      })
    }
  }]
})));
function b(o) {
  const {
    checked: a = !1,
    classes: t = {},
    fontSize: s
  } = o, n = {
    ...o,
    checked: a
  };
  return /* @__PURE__ */ _(Q, {
    className: t.root,
    ownerState: n,
    children: [/* @__PURE__ */ r(W, {
      fontSize: s,
      className: t.background,
      ownerState: n
    }), /* @__PURE__ */ r(X, {
      fontSize: s,
      className: t.dot,
      ownerState: n
    })]
  });
}
process.env.NODE_ENV !== "production" && (b.propTypes = {
  /**
   * If `true`, the component is checked.
   */
  checked: e.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: e.object,
  /**
   * The size of the component.
   * `small` is equivalent to the dense radio styling.
   */
  fontSize: e.oneOf(["small", "medium"])
});
const w = /* @__PURE__ */ l.createContext(void 0);
process.env.NODE_ENV !== "production" && (w.displayName = "RadioGroupContext");
function Y() {
  return l.useContext(w);
}
function oo(o) {
  return D("MuiRadio", o);
}
const h = U("MuiRadio", ["root", "checked", "disabled", "colorPrimary", "colorSecondary", "sizeSmall"]), eo = (o) => {
  const {
    classes: a,
    color: t,
    size: s
  } = o, n = {
    root: ["root", `color${d(t)}`, s !== "medium" && `size${d(s)}`]
  };
  return {
    ...a,
    ...H(n, oo, a)
  };
}, ao = p(V, {
  shouldForwardProp: (o) => O(o) || o === "classes",
  name: "MuiRadio",
  slot: "Root",
  overridesResolver: (o, a) => {
    const {
      ownerState: t
    } = o;
    return [a.root, t.size !== "medium" && a[`size${d(t.size)}`], a[`color${d(t.color)}`]];
  }
})(I(({
  theme: o
}) => ({
  color: (o.vars || o).palette.text.secondary,
  [`&.${h.disabled}`]: {
    color: (o.vars || o).palette.action.disabled
  },
  variants: [{
    props: {
      color: "default",
      disabled: !1,
      disableRipple: !1
    },
    style: {
      "&:hover": {
        backgroundColor: o.vars ? `rgba(${o.vars.palette.action.activeChannel} / ${o.vars.palette.action.hoverOpacity})` : R(o.palette.action.active, o.palette.action.hoverOpacity)
      }
    }
  }, ...Object.entries(o.palette).filter(g()).map(([a]) => ({
    props: {
      color: a,
      disabled: !1,
      disableRipple: !1
    },
    style: {
      "&:hover": {
        backgroundColor: o.vars ? `rgba(${o.vars.palette[a].mainChannel} / ${o.vars.palette.action.hoverOpacity})` : R(o.palette[a].main, o.palette.action.hoverOpacity)
      }
    }
  })), ...Object.entries(o.palette).filter(g()).map(([a]) => ({
    props: {
      color: a,
      disabled: !1
    },
    style: {
      [`&.${h.checked}`]: {
        color: (o.vars || o).palette[a].main
      }
    }
  })), {
    // Should be last to override other colors
    props: {
      disableRipple: !1
    },
    style: {
      // Reset on touch devices, it doesn't add specificity
      "&:hover": {
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }]
})));
function to(o, a) {
  return typeof a == "object" && a !== null ? o === a : String(o) === String(a);
}
const S = /* @__PURE__ */ r(b, {
  checked: !0
}), k = /* @__PURE__ */ r(b, {}), so = /* @__PURE__ */ l.forwardRef(function(a, t) {
  const s = q({
    props: a,
    name: "MuiRadio"
  }), {
    checked: n,
    checkedIcon: N = S,
    color: P = "primary",
    icon: x = k,
    name: j,
    onChange: B,
    size: u = "medium",
    className: $,
    disabled: E,
    disableRipple: T = !1,
    ...F
  } = s, y = L();
  let i = E;
  y && typeof i > "u" && (i = y.disabled), i ?? (i = !1);
  const C = {
    ...s,
    disabled: i,
    disableRipple: T,
    color: P,
    size: u
  }, v = eo(C), c = Y();
  let f = n;
  const M = A(B, c && c.onChange);
  let m = j;
  return c && (typeof f > "u" && (f = to(c.value, s.value)), typeof m > "u" && (m = c.name)), /* @__PURE__ */ r(ao, {
    type: "radio",
    icon: /* @__PURE__ */ l.cloneElement(x, {
      fontSize: k.props.fontSize ?? u
    }),
    checkedIcon: /* @__PURE__ */ l.cloneElement(N, {
      fontSize: S.props.fontSize ?? u
    }),
    disabled: i,
    ownerState: C,
    classes: v,
    name: m,
    checked: f,
    onChange: M,
    ref: t,
    className: G(v.root, $),
    ...F
  });
});
process.env.NODE_ENV !== "production" && (so.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * If `true`, the component is checked.
   */
  checked: e.bool,
  /**
   * The icon to display when the component is checked.
   * @default <RadioButtonIcon checked />
   */
  checkedIcon: e.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: e.object,
  /**
   * @ignore
   */
  className: e.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * @default 'primary'
   */
  color: e.oneOfType([e.oneOf(["default", "primary", "secondary", "error", "info", "success", "warning"]), e.string]),
  /**
   * If `true`, the component is disabled.
   */
  disabled: e.bool,
  /**
   * If `true`, the ripple effect is disabled.
   * @default false
   */
  disableRipple: e.bool,
  /**
   * The icon to display when the component is unchecked.
   * @default <RadioButtonIcon />
   */
  icon: e.node,
  /**
   * The id of the `input` element.
   */
  id: e.string,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */
  inputProps: e.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: Z,
  /**
   * Name attribute of the `input` element.
   */
  name: e.string,
  /**
   * Callback fired when the state is changed.
   *
   * @param {React.ChangeEvent<HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   * You can pull out the new checked state by accessing `event.target.checked` (boolean).
   */
  onChange: e.func,
  /**
   * If `true`, the `input` element is required.
   * @default false
   */
  required: e.bool,
  /**
   * The size of the component.
   * `small` is equivalent to the dense radio styling.
   * @default 'medium'
   */
  size: e.oneOfType([e.oneOf(["medium", "small"]), e.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: e.oneOfType([e.arrayOf(e.oneOfType([e.func, e.object, e.bool])), e.func, e.object]),
  /**
   * The value of the component. The DOM API casts this to a string.
   */
  value: e.any
});
export {
  w as R,
  so as a
};
